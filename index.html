<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>TITAN OMEGA — CHRONO SYNC</title>
<style>
  :root{
    --bg:#020617;
    --film-yellow:#FFE08A;
    --rim-cyan:#00F0FF;
    --core-mag:#FF3FB5;
    --steel:#0b1220;
    --smoke:#4a4a4a;
    --safe-top:env(safe-area-inset-top,0px);
    --safe-bottom:env(safe-area-inset-bottom,0px);
    --ui-font: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:var(--ui-font);-webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;overflow:hidden;}
  #app{position:fixed;inset:0;padding-top:var(--safe-top);padding-bottom:var(--safe-bottom);display:flex;align-items:center;justify-content:center;touch-action:none}
  .stage{position:relative;width:430px;height:932px;max-width:100vw;max-height:100vh;box-shadow:0 10px 40px rgba(0,0,0,0.6);background:linear-gradient(180deg,#020617 0%, #07102a 100%);overflow:hidden;border-radius:8px}
  canvas{width:100%;height:100%;display:block;image-rendering:pixelated}
  /* Letterbox bars */
  .bar{position:absolute;left:0;right:0;height:12%;background:linear-gradient(180deg,rgba(0,0,0,0.85),rgba(0,0,0,0.6));opacity:0;pointer-events:none;transition:opacity .6s}
  .bar.top{top:0}
  .bar.bottom{bottom:0}
  .bar.show{opacity:1}
  /* UI overlay */
  .ui{position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none}
  .hud{position:absolute;left:12px;right:12px;top:12px;display:flex;justify-content:space-between;align-items:center;pointer-events:auto}
  .counter{background:rgba(0,0,0,0.25);backdrop-filter:blur(4px);padding:6px 10px;border-radius:8px;font-weight:700;letter-spacing:1px;font-size:13px}
  .center-hud{position:absolute;left:50%;transform:translateX(-50%);top:40px;text-align:center;pointer-events:none}
  .timer{font-size:28px;font-weight:900;letter-spacing:2px}
  .subtitle{font-size:11px;opacity:0.9}
  .bossbar{position:absolute;left:50%;transform:translateX(-50%);top:86px;width:70%;height:18px;background:rgba(255,255,255,0.06);border-radius:10px;overflow:hidden;box-shadow:inset 0 -2px 6px rgba(0,0,0,0.6)}
  .bossbar .fill{height:100%;background:linear-gradient(90deg,var(--core-mag),var(--rim-cyan));width:100%;transition:width .12s linear}
  .bossbar .label{position:absolute;left:50%;top:-22px;transform:translateX(-50%);font-weight:800;font-size:12px;color:var(--film-yellow)}
  .controls{position:absolute;left:12px;right:12px;bottom:18px;display:flex;justify-content:space-between;gap:8px;pointer-events:auto}
  .btn{flex:1;padding:12px 10px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(0,0,0,0.15));border:1px solid rgba(255,255,255,0.04);color:#fff;font-weight:800;letter-spacing:1px;text-align:center;user-select:none;touch-action:manipulation}
  .btn.disabled{opacity:0.35;pointer-events:none;filter:grayscale(.2)}
  .titleCard{position:absolute;left:0;right:0;top:40%;transform:translateY(-50%);text-align:center;pointer-events:none}
  .titleCard h1{font-size:36px;color:var(--film-yellow);margin:0;letter-spacing:6px;font-weight:900}
  .crawlWrap{position:absolute;left:6%;right:6%;top:48%;height:40%;overflow:hidden;pointer-events:none;transform-origin:center top}
  .crawl{color:var(--film-yellow);font-weight:800;line-height:1.6;letter-spacing:3px;text-transform:uppercase;font-size:14px;transform:skewX(-18deg);white-space:pre-wrap}
  .overlayBig{position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .bigDigit{font-size:160px;font-weight:900;color:#fff;text-shadow:0 6px 30px rgba(0,0,0,0.8);pointer-events:none}
  .victory{position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;flex-direction:column;pointer-events:auto;opacity:0;transition:opacity .6s}
  .victory.show{opacity:1}
  .victory h2{font-size:28px;color:var(--film-yellow);letter-spacing:6px;margin:0}
  .victory p{margin:8px 0 0 0;font-weight:700}
  /* film overlays */
  .grain, .halftone, .scanlines{position:absolute;inset:0;pointer-events:none;mix-blend-mode:overlay;opacity:0.06}
  .halftone{opacity:0.08;mix-blend-mode:soft-light}
  .scanlines{background-image:linear-gradient(rgba(255,255,255,0.02) 50%, rgba(0,0,0,0.02) 50%);background-size:100% 4px;opacity:0.06;mix-blend-mode:overlay}
  /* small HUD buttons */
  .smallBtns{position:absolute;right:12px;top:12px;display:flex;flex-direction:column;gap:8px;pointer-events:auto}
  .small{padding:8px 10px;border-radius:8px;background:rgba(0,0,0,0.35);font-weight:800;font-size:12px}
  /* accessibility focus */
  .btn:focus,.small:focus{outline:2px solid var(--film-yellow);outline-offset:2px}
  /* reduced motion fallback */
  @media (prefers-reduced-motion: reduce){
    .crawl{transition:none!important;animation:none!important}
  }
</style>
</head>
<body>
<div id="app" role="application" aria-label="Titan Omega Chrono Sync App">
  <div class="stage" id="stage" role="region" aria-roledescription="game canvas">
    <canvas id="mainCanvas" width="430" height="932" aria-hidden="true"></canvas>

    <div class="bar top" id="barTop" aria-hidden="true"></div>
    <div class="bar bottom" id="barBottom" aria-hidden="true"></div>

    <div class="ui" aria-hidden="false">
      <div class="hud" id="hud">
        <div class="counter" id="crystals">CRYSTALS: 0</div>
        <div class="counter" id="streak">STREAK: 0</div>
      </div>

      <div class="center-hud" aria-hidden="false">
        <div class="bossbar" role="progressbar" aria-label="Titan Omega Core Health" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100" id="bossBar">
          <div class="label" id="bossLabel">TITAN OMEGA CORE</div>
          <div class="fill" id="bossFill" style="width:100%"></div>
        </div>
        <div style="height:12px"></div>
        <div class="timer" id="timer" aria-live="polite" aria-atomic="true">02:00</div>
        <div class="subtitle">CHRONO SYNC</div>
      </div>

      <div class="controls" id="controls" aria-hidden="false">
        <div class="btn" id="launchBtn">LAUNCH MISSION</div>
        <div class="btn" id="skipBtn">SKIP PROLOGUE</div>
        <div class="btn" id="engageBtn">ENGAGE</div>
      </div>

      <div class="smallBtns">
        <div class="small" id="muteBtn">SILENCE</div>
        <div class="small" id="skipCountBtn">SKIP COUNT</div>
      </div>

      <div class="titleCard" id="titleCard" aria-hidden="false">
        <h1>MISSION CHRONO SYNC</h1>
      </div>

      <div class="crawlWrap" id="crawlWrap" aria-hidden="true">
        <div class="crawl" id="crawlText">
PROLOGUE

THE ORBITING TITAN OMEGA HAS RUPTURED THE CHRONO GRID.
A LONE PILOT MUST SYNC THE CHRONO CORE BEFORE THE ORBIT COLLAPSES.
SUIT UP. TWO MINUTES OF STEADY RHYTHM WILL RESTORE THE CORE AND BRING THE TITAN DOWN.
THIS IS YOUR MISSION. THIS IS YOUR MOMENT.
        </div>
      </div>

      <div class="overlayBig" id="overlayBig" aria-hidden="true">
        <div class="bigDigit" id="bigDigit" aria-hidden="true">5</div>
      </div>

      <div class="victory" id="victory" role="dialog" aria-live="polite">
        <h2 id="victoryTitle">TITAN OMEGA FALLEN</h2>
        <p id="victoryText">CALLSIGN: <span id="pilotName">UNKNOWN</span></p>
        <div style="height:12px"></div>
        <div class="btn" id="returnBtn">RETURN</div>
      </div>

      <canvas class="grain" id="grainCanvas" width="430" height="932" aria-hidden="true"></canvas>
      <canvas class="halftone" id="halftoneCanvas" width="430" height="932" aria-hidden="true"></canvas>
      <div class="scanlines" aria-hidden="true"></div>
    </div>
  </div>
</div>

<script>
/* ============================================================
   TITAN OMEGA — CHRONO SYNC
   Single-file production-ready drop-in index.html
   Sections: CONFIG, STATE, CANVAS SETUP, UTILS, AUDIO,
             POOLS, STARS, TITAN, HERO, INPUT, UPDATE, RENDER, UI, LOOP
   ============================================================ */

/* ===========================
   CONFIG
   =========================== */
const CONFIG = {
  canvasW: 430,
  canvasH: 932,
  titleCardHold: 1.2, // seconds
  crawlDuration: 18, // seconds default
  precountdown: 5, // seconds
  duration: 120, // main brushing session seconds
  bossMaxHP: 1000,
  particlesCap: 180,
  debrisCap: 100,
  grainHz: 10,
  reducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
  muteKey: 'titan_mute',
  storageKeys: {
    crystals: 'titan_crystals',
    streak: 'titan_streak',
    best: 'titan_best',
    pilot: 'titan_pilot',
    mute: 'titan_mute'
  }
};

/* ===========================
   STATE
   =========================== */
const STATE = {
  view: 'title', // title, crawl, precount, main, final, victory
  time: 0,
  lastTime: 0,
  dt: 0,
  running: false,
  audioReady: false,
  audioMuted: localStorage.getItem(CONFIG.storageKeys.mute) === '1',
  bossHP: CONFIG.bossMaxHP,
  drainPerSecond: CONFIG.bossMaxHP / CONFIG.duration,
  crystals: parseInt(localStorage.getItem(CONFIG.storageKeys.crystals) || '0',10),
  streak: parseInt(localStorage.getItem(CONFIG.storageKeys.streak) || '0',10),
  best: parseInt(localStorage.getItem(CONFIG.storageKeys.best) || '0',10),
  pilot: localStorage.getItem(CONFIG.storageKeys.pilot) || '',
  precount: CONFIG.precountdown,
  crawlProgress: 0,
  countdownStarted: false,
  mainStarted: false,
  finalStarted: false,
  victoryShown: false,
  particlesActive: 0,
  debrisActive: 0,
  pools: {}
};

/* ===========================
   CANVAS SETUP
   =========================== */
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
canvas.width = CONFIG.canvasW;
canvas.height = CONFIG.canvasH;

const grainCanvas = document.getElementById('grainCanvas');
const grainCtx = grainCanvas.getContext('2d');
grainCanvas.width = CONFIG.canvasW;
grainCanvas.height = CONFIG.canvasH;

const halftoneCanvas = document.getElementById('halftoneCanvas');
const halftoneCtx = halftoneCanvas.getContext('2d');
halftoneCanvas.width = CONFIG.canvasW;
halftoneCanvas.height = CONFIG.canvasH;

/* Respect safe area insets for iOS home screen */
function fitStage() {
  const stage = document.getElementById('stage');
  // CSS scaling handled by canvas width/height and CSS; keep aspect ratio
  // No scrolling; ensure stage fits viewport
  const vw = Math.min(window.innerWidth, CONFIG.canvasW);
  const vh = Math.min(window.innerHeight, CONFIG.canvasH);
  // Let CSS handle scaling; nothing else needed here
}
window.addEventListener('resize', fitStage);
fitStage();

/* ===========================
   UTILS
   =========================== */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;
const rand = (a=0,b=1)=>a + Math.random()*(b-a);
const pick = arr => arr[Math.floor(Math.random()*arr.length)];
const now = ()=>performance.now()/1000;

/* ===========================
   AUDIO (WebAudio procedural)
   =========================== */
let audioCtx = null;
let masterGain = null;
let sfxGain = null;
let musicGain = null;

function ensureAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain(); masterGain.gain.value = STATE.audioMuted ? 0 : 1;
  sfxGain = audioCtx.createGain(); sfxGain.gain.value = 0.9;
  musicGain = audioCtx.createGain(); musicGain.gain.value = 0.6;
  sfxGain.connect(masterGain);
  musicGain.connect(masterGain);
  masterGain.connect(audioCtx.destination);
  STATE.audioReady = true;
}

/* simple synth helpers */
function playOsc({type='sine',freq=440,dur=0.2,when=0, gain=0.12, detune=0, pan=0, filterFreq=null}) {
  if (!audioCtx) return;
  const t = audioCtx.currentTime + when;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq; o.detune.value = detune;
  g.gain.setValueAtTime(gain*0.0001, t);
  g.gain.exponentialRampToValueAtTime(gain, t+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
  let node = o;
  if (filterFreq) {
    const f = audioCtx.createBiquadFilter();
    f.type = 'lowpass'; f.frequency.value = filterFreq;
    node.connect(f);
    node = f;
  }
  node.connect(g);
  g.connect(sfxGain);
  o.start(t);
  o.stop(t+dur+0.02);
}

/* layered stings and effects */
function titleSting() {
  ensureAudio();
  // saw sweep + sine hit
  const t = audioCtx.currentTime;
  const o1 = audioCtx.createOscillator(); o1.type='saw'; o1.frequency.value=220;
  const o2 = audioCtx.createOscillator(); o2.type='sine'; o2.frequency.value=880;
  const g1 = audioCtx.createGain(); const g2 = audioCtx.createGain();
  g1.gain.value=0.0001; g2.gain.value=0.0001;
  o1.connect(g1); o2.connect(g2);
  g1.connect(musicGain); g2.connect(musicGain);
  g1.gain.setValueAtTime(0.0001,t); g1.gain.exponentialRampToValueAtTime(0.18,t+0.25); g1.gain.exponentialRampToValueAtTime(0.0001,t+0.8);
  g2.gain.setValueAtTime(0.0001,t+0.2); g2.gain.exponentialRampToValueAtTime(0.28,t+0.4); g2.gain.exponentialRampToValueAtTime(0.0001,t+0.9);
  o1.frequency.setValueAtTime(220,t); o1.frequency.exponentialRampToValueAtTime(880,t+0.8);
  o1.start(t); o2.start(t+0.18);
  o1.stop(t+1.0); o2.stop(t+1.0);
}

function countdownTick(i, final=false) {
  ensureAudio();
  const base = 220 + i*40;
  playOsc({type:'sine',freq:base,dur:0.08,gain:0.06});
  if (final) {
    // whoosh + saw
    playOsc({type:'saw',freq:440,dur:0.6,gain:0.18,filterFreq:1200});
    // noise whoosh
    const bufferSize = 2*audioCtx.sampleRate;
    const noise = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = noise.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1)*Math.exp(-i/bufferSize*4);
    const src = audioCtx.createBufferSource(); src.buffer = noise;
    const f = audioCtx.createBiquadFilter(); f.type='highpass'; f.frequency.value=800;
    src.connect(f); f.connect(sfxGain);
    src.start();
  }
}

function laserSfx() {
  ensureAudio();
  playOsc({type:'saw',freq:1200,dur:0.08,gain:0.08,filterFreq:2000});
  // filtered noise burst
  const bufferSize = 0.5*audioCtx.sampleRate|0;
  const noise = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = noise.getChannelData(0);
  for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1)*Math.exp(-i/bufferSize*6);
  const src = audioCtx.createBufferSource(); src.buffer = noise;
  const f = audioCtx.createBiquadFilter(); f.type='bandpass'; f.frequency.value=1800; f.Q.value=1;
  src.connect(f); f.connect(sfxGain);
  src.start();
}

function damageArp() {
  ensureAudio();
  const t = audioCtx.currentTime;
  playOsc({type:'sine',freq:660,dur:0.12,gain:0.06,when:0});
  playOsc({type:'sine',freq:880,dur:0.12,gain:0.06,when:0.08});
  playOsc({type:'sine',freq:990,dur:0.12,gain:0.06,when:0.16});
}

function finalNuke() {
  ensureAudio();
  const t = audioCtx.currentTime;
  // sub-sine swell
  const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.value=80;
  const g = audioCtx.createGain(); g.gain.value=0.0001;
  o.connect(g); g.connect(musicGain);
  g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(1.2,t+1.2); g.gain.exponentialRampToValueAtTime(0.0001,t+6);
  o.start(t); o.stop(t+6.2);
  // mid saw cluster
  for (let i=0;i<3;i++){
    playOsc({type:'saw',freq:400+ i*30,dur:1.8,gain:0.18,when:0.12,filterFreq:2000});
  }
  // crackle tail
  const bufferSize = 1.5*audioCtx.sampleRate|0;
  const noise = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = noise.getChannelData(0);
  for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1)*Math.exp(-i/bufferSize*1.2);
  const src = audioCtx.createBufferSource(); src.buffer = noise;
  const f = audioCtx.createBiquadFilter(); f.type='highpass'; f.frequency.value=1200;
  src.connect(f); f.connect(sfxGain);
  src.start(audioCtx.currentTime+0.12);
}

/* Mute toggle */
function setMute(m) {
  STATE.audioMuted = !!m;
  localStorage.setItem(CONFIG.storageKeys.mute, STATE.audioMuted ? '1' : '0');
  if (masterGain) masterGain.gain.value = STATE.audioMuted ? 0 : 1;
  document.getElementById('muteBtn').textContent = STATE.audioMuted ? 'SOUND ON' : 'SILENCE';
}

/* ===========================
   POOLS (particles & debris)
   =========================== */
function createPool(type, size, factory) {
  const pool = {items:[], free:[], active:0};
  for (let i=0;i<size;i++){
    const it = factory();
    pool.items.push(it);
    pool.free.push(it);
  }
  return pool;
}

/* particle factory */
function particleFactory() {
  return {x:0,y:0,vx:0,vy:0,life:0,ttl:0,size:1,color:'#fff',active:false};
}
function debrisFactory() {
  return {x:0,y:0,vx:0,vy:0,rot:0,rotv:0,life:0,ttl:0,size:1,color:'#666',active:false};
}

/* init pools */
STATE.pools.particles = createPool('particles', CONFIG.particlesCap, particleFactory);
STATE.pools.debris = createPool('debris', CONFIG.debrisCap, debrisFactory);

/* spawn helpers */
function spawnParticle(x,y,vx,vy,ttl,size,color) {
  const pool = STATE.pools.particles;
  const it = pool.free.pop();
  if (!it) return; // safe fallback: drop particle
  it.x = x; it.y = y; it.vx = vx; it.vy = vy; it.life = 0; it.ttl = ttl; it.size = size; it.color = color; it.active = true;
  pool.active++;
}
function spawnDebris(x,y,vx,vy,rotv,ttl,size,color) {
  const pool = STATE.pools.debris;
  const it = pool.free.pop();
  if (!it) return;
  it.x = x; it.y = y; it.vx = vx; it.vy = vy; it.rot = Math.random()*Math.PI*2; it.rotv = rotv; it.life = 0; it.ttl = ttl; it.size = size; it.color = color; it.active = true;
  pool.active++;
}

/* recycle functions */
function updatePools(dt) {
  const p = STATE.pools.particles;
  for (let i=0;i<p.items.length;i++){
    const it = p.items[i];
    if (!it.active) continue;
    it.life += dt;
    if (it.life >= it.ttl) { it.active=false; p.free.push(it); p.active--; continue; }
    it.x += it.vx*dt; it.y += it.vy*dt; it.vy += 80*dt; // gravity
  }
  const d = STATE.pools.debris;
  for (let i=0;i<d.items.length;i++){
    const it = d.items[i];
    if (!it.active) continue;
    it.life += dt;
    if (it.life >= it.ttl) { it.active=false; d.free.push(it); d.active--; continue; }
    it.x += it.vx*dt; it.y += it.vy*dt; it.vy += 40*dt; it.rot += it.rotv*dt;
  }
}

/* ===========================
   STARS (parallax starfield)
   =========================== */
const STARS = [];
for (let i=0;i<120;i++){
  STARS.push({
    x: Math.random()*CONFIG.canvasW,
    y: Math.random()*CONFIG.canvasH,
    z: Math.random()*1.5+0.2,
    twinkle: Math.random()*1.2
  });
}

/* ===========================
   TITAN (procedural dreadnought)
   =========================== */
const TITAN = {
  x: CONFIG.canvasW*0.5,
  y: CONFIG.canvasH*0.36,
  w: 220,
  h: 420,
  damage: 0 // 0..1
};

function drawTitan(ctx, hpFrac) {
  // layered plates, seams, rivets, weak core rings
  const x = TITAN.x, y = TITAN.y, w = TITAN.w, h = TITAN.h;
  ctx.save();
  // base shadow
  ctx.translate(x,y);
  // body
  ctx.fillStyle = CONFIG.steel || '#0b1220';
  roundRect(ctx, -w/2, -h/2, w, h, 18);
  ctx.fill();
  // panel seams
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1;
  for (let i= -h/2+30;i<h/2-20;i+=40){
    ctx.beginPath(); ctx.moveTo(-w/2+8,i); ctx.lineTo(w/2-8,i); ctx.stroke();
  }
  // rivets
  for (let rx=-w/2+12; rx<w/2-10; rx+=24){
    for (let ry=-h/2+12; ry<h/2-10; ry+=36){
      ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.arc(rx,ry,2,0,Math.PI*2); ctx.fill();
    }
  }
  // core
  const coreR = 36;
  const corePulse = 1 + 0.08*Math.sin(perfTime()*6);
  const coreColor = hpFrac>0.25 ? CONFIG.coreMag || '#FF3FB5' : '#ff8fb5';
  // weak-point rings
  for (let i=3;i>=0;i--){
    const r = coreR + i*12*corePulse;
    ctx.beginPath();
    ctx.strokeStyle = `rgba(255,255,255,${0.06 - i*0.01})`;
    ctx.lineWidth = 2;
    ctx.arc(0, h/4, r, 0, Math.PI*2);
    ctx.stroke();
  }
  // core glow
  const g = ctx.createRadialGradient(0,h/4,6,0,h/4,120);
  g.addColorStop(0, hexToRgba(coreColor, 0.95));
  g.addColorStop(0.4, hexToRgba(coreColor, 0.35));
  g.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(0,h/4,120,0,Math.PI*2); ctx.fill();
  // core center
  ctx.beginPath(); ctx.fillStyle = coreColor; ctx.arc(0,h/4,coreR*corePulse,0,Math.PI*2); ctx.fill();
  // damage gashes based on hp thresholds
  const dmg = 1 - hpFrac;
  if (dmg > 0.25) {
    // scorch marks
    const g2 = ctx.createRadialGradient(-w/4, -h/8, 0, -w/4, -h/8, 80);
    g2.addColorStop(0, 'rgba(0,0,0,0.6)');
    g2.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g2; ctx.beginPath(); ctx.arc(-w/4, -h/8, 80, 0, Math.PI*2); ctx.fill();
  }
  if (dmg > 0.5) {
    // gash
    ctx.strokeStyle = 'rgba(255,80,80,0.12)'; ctx.lineWidth = 6;
    ctx.beginPath(); ctx.moveTo(-w/4,0); ctx.lineTo(w/4, h/6); ctx.stroke();
    // spawn debris occasionally
    if (Math.random() < 0.02) spawnDebris(x + rand(-40,40), y + rand(-80,80), rand(-120,120), rand(-200,-60), rand(-3,3), rand(1.2,2.8), rand(4,8), '#6b6b6b');
  }
  if (dmg > 0.75) {
    // big gash
    ctx.strokeStyle = 'rgba(255,120,120,0.18)'; ctx.lineWidth = 10;
    ctx.beginPath(); ctx.moveTo(-w/3, h/8); ctx.lineTo(w/3, h/2 - 40); ctx.stroke();
    if (Math.random() < 0.06) {
      for (let i=0;i<6;i++) spawnParticle(x + rand(-60,60), y + rand(40,160), rand(-200,200), rand(-300,-80), rand(0.6,1.6), rand(1,3), '#ffb3d9');
    }
  }
  ctx.restore();
}

/* helper: rounded rect */
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* ===========================
   HERO (foreground silhouette)
   =========================== */
function drawHero(ctx) {
  const x = CONFIG.canvasW*0.5;
  const y = CONFIG.canvasH*0.78;
  ctx.save();
  ctx.translate(x,y);
  // silhouette
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.moveTo(-28,0);
  ctx.quadraticCurveTo(-40,-40,-18,-70);
  ctx.quadraticCurveTo(-6,-90,10,-92);
  ctx.quadraticCurveTo(30,-94,44,-70);
  ctx.quadraticCurveTo(60,-40,48,0);
  ctx.closePath();
  ctx.fill();
  // visor rim
  const rim = ctx.createLinearGradient(-20,-70,20,-70);
  rim.addColorStop(0, CONFIG.rimCyan || '#00F0FF');
  rim.addColorStop(1, CONFIG.coreMag || '#FF3FB5');
  ctx.strokeStyle = rim;
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(-18,-72); ctx.quadraticCurveTo(0,-86,18,-72); ctx.stroke();
  // chest emblem
  ctx.fillStyle = 'rgba(0,255,255,0.06)';
  ctx.beginPath(); ctx.arc(0,-40,8,0,Math.PI*2); ctx.fill();
  // holo reticle above head
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.arc(0,-100,14,0,Math.PI*2); ctx.stroke();
  ctx.restore();
}

/* ===========================
   INPUT
   =========================== */
document.addEventListener('DOMContentLoaded', ()=> {
  // attach handlers
  const launchBtn = document.getElementById('launchBtn');
  const skipBtn = document.getElementById('skipBtn');
  const engageBtn = document.getElementById('engageBtn');
  const muteBtn = document.getElementById('muteBtn');
  const skipCountBtn = document.getElementById('skipCountBtn');
  const returnBtn = document.getElementById('returnBtn');

  launchBtn.addEventListener('click', ()=> startPrologue());
  skipBtn.addEventListener('click', ()=> skipPrologue());
  engageBtn.addEventListener('click', ()=> startPrecount());
  muteBtn.addEventListener('click', ()=> { setMute(!STATE.audioMuted); });
  skipCountBtn.addEventListener('click', ()=> skipCountdown());
  returnBtn.addEventListener('click', ()=> resetToTitle());

  // touch to resume audio context for iOS
  document.body.addEventListener('touchend', resumeAudioOnFirstTouch, {passive:true});
  document.body.addEventListener('click', resumeAudioOnFirstTouch, {passive:true});

  // keyboard
  window.addEventListener('keydown', (e)=>{
    if (e.code === 'Space') { e.preventDefault(); if (STATE.view === 'main' && !STATE.mainStarted) return; /* disabled during brushing */ }
    if (e.key.toLowerCase() === 'm') { setMute(!STATE.audioMuted); }
    if (e.key.toLowerCase() === 'p') { /* pause/resume - disabled during brushing */ if (STATE.view !== 'main') togglePause(); }
  });

  // initial UI state
  document.getElementById('crystals').textContent = `CRYSTALS: ${STATE.crystals}`;
  document.getElementById('streak').textContent = `STREAK: ${STATE.streak}`;
  document.getElementById('muteBtn').textContent = STATE.audioMuted ? 'SOUND ON' : 'SILENCE';
});

/* resume audio */
function resumeAudioOnFirstTouch(e) {
  if (STATE.audioReady) return;
  try {
    ensureAudio();
    // small silent buffer to unlock
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    g.gain.value = 0; o.start(); o.stop(audioCtx.currentTime+0.01);
  } catch (err) {
    // ignore
  }
}

/* ===========================
   UI FLOW CONTROLS
   =========================== */
function startPrologue() {
  setView('title');
  // show title for hold then crawl
  titleSting();
  setTimeout(()=> {
    setView('crawl');
    startCrawl(CONFIG.crawlDuration);
  }, CONFIG.titleCardHold*1000);
}

function skipPrologue() {
  setView('precount');
  startPrecount();
}

function startCrawl(duration) {
  const wrap = document.getElementById('crawlWrap');
  wrap.style.opacity = 1;
  wrap.setAttribute('aria-hidden','false');
  document.getElementById('titleCard').style.display = 'none';
  // animate crawl by CSS transform over duration
  const crawl = document.getElementById('crawlText');
  crawl.style.transform = 'translateY(120%) skewX(-18deg)';
  // initial position above
  crawl.style.transition = `transform ${duration}s linear`;
  // force reflow
  void crawl.offsetWidth;
  crawl.style.transform = 'translateY(-220%) skewX(-18deg)';
  // show letterbox
  document.getElementById('barTop').classList.add('show');
  document.getElementById('barBottom').classList.add('show');
  // after duration, proceed to precount
  setTimeout(()=> {
    wrap.style.opacity = 0;
    wrap.setAttribute('aria-hidden','true');
    document.getElementById('barTop').classList.remove('show');
    document.getElementById('barBottom').classList.remove('show');
    startPrecount();
  }, duration*1000);
}

function skipCountdown() {
  if (STATE.view === 'precount') {
    // jump to main
    startMainSession();
  }
}

function startPrecount() {
  setView('precount');
  STATE.precount = CONFIG.precountdown;
  document.getElementById('overlayBig').style.pointerEvents = 'none';
  document.getElementById('overlayBig').setAttribute('aria-hidden','false');
  const big = document.getElementById('bigDigit');
  big.style.opacity = 1;
  // audible ticks
  let i = STATE.precount;
  const tick = ()=> {
    if (i <= 0) {
      countdownTick(0, true);
      document.getElementById('overlayBig').setAttribute('aria-hidden','true');
      startMainSession();
      return;
    }
    big.textContent = String(i);
    countdownTick(i, i===1);
    i--;
    setTimeout(tick, 1000);
  };
  tick();
}

function startMainSession() {
  setView('main');
  STATE.mainStarted = true;
  STATE.bossHP = CONFIG.bossMaxHP;
  STATE.drainPerSecond = CONFIG.bossMaxHP / CONFIG.duration;
  STATE.time = 0;
  STATE.lastTime = now();
  // disable controls visually
  document.querySelectorAll('.btn').forEach(b=>b.classList.add('disabled'));
  document.querySelectorAll('.small').forEach(b=>b.classList.add('disabled'));
  // show letterbox during main? not necessary; but ensure HUD shows
  // start deterministic drain
  STATE.running = true;
  // start loop if not already
  if (!looping) requestAnimationFrame(loop);
}

function startFinalCinematic() {
  if (STATE.finalStarted) return;
  STATE.finalStarted = true;
  setView('final');
  // play final nuke audio
  finalNuke();
  // show letterbox
  document.getElementById('barTop').classList.add('show');
  document.getElementById('barBottom').classList.add('show');
  // choreograph phases via timeouts
  // flash
  flashScreen(0.12);
  // spawn debris and particles
  for (let i=0;i<60;i++){
    spawnDebris(TITAN.x + rand(-80,80), TITAN.y + rand(-40,120), rand(-600,600), rand(-800,-200), rand(-6,6), rand(0.8,2.4), rand(3,8), '#8b6b9a');
  }
  // after afterglow, show victory overlay
  setTimeout(()=> {
    showVictory();
  }, 1600);
}

/* flash helper */
function flashScreen(duration) {
  const start = now();
  const flash = (t)=>{
    const elapsed = now()-start;
    const alpha = Math.max(0, 1 - elapsed/duration);
    ctx.save();
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.fillRect(0,0,CONFIG.canvasW,CONFIG.canvasH);
    ctx.restore();
  };
  // schedule a few frames of flash via temporary flag
  let frames = 0;
  const id = setInterval(()=>{
    frames++;
    if (frames>6) { clearInterval(id); return; }
  }, 16);
}

/* show victory overlay and persist stats */
function showVictory() {
  setView('victory');
  STATE.victoryShown = true;
  // update stats
  STATE.crystals += Math.floor(CONFIG.bossMaxHP/100);
  STATE.streak += 1;
  STATE.best = Math.max(STATE.best, STATE.streak);
  localStorage.setItem(CONFIG.storageKeys.crystals, String(STATE.crystals));
  localStorage.setItem(CONFIG.storageKeys.streak, String(STATE.streak));
  localStorage.setItem(CONFIG.storageKeys.best, String(STATE.best));
  localStorage.setItem(CONFIG.storageKeys.pilot, STATE.pilot || '');
  // update UI
  document.getElementById('crystals').textContent = `CRYSTALS: ${STATE.crystals}`;
  document.getElementById('streak').textContent = `STREAK: ${STATE.streak}`;
  document.getElementById('victory').classList.add('show');
  document.getElementById('pilotName').textContent = STATE.pilot || 'UNKNOWN';
  // re-enable controls
  document.querySelectorAll('.btn').forEach(b=>b.classList.remove('disabled'));
  document.querySelectorAll('.small').forEach(b=>b.classList.remove('disabled'));
}

/* reset to title */
function resetToTitle() {
  setView('title');
  document.getElementById('victory').classList.remove('show');
  document.getElementById('titleCard').style.display = 'block';
  document.getElementById('barTop').classList.remove('show');
  document.getElementById('barBottom').classList.remove('show');
  STATE.finalStarted = false;
  STATE.mainStarted = false;
  STATE.victoryShown = false;
  STATE.running = false;
}

/* toggle pause (not allowed during main) */
function togglePause() {
  STATE.running = !STATE.running;
  if (STATE.running) { STATE.lastTime = now(); requestAnimationFrame(loop); }
}

/* set view helper */
function setView(v) {
  STATE.view = v;
  // manage UI visibility
  const title = document.getElementById('titleCard');
  const crawl = document.getElementById('crawlWrap');
  const overlay = document.getElementById('overlayBig');
  if (v === 'title') { title.style.display='block'; crawl.style.opacity=0; overlay.setAttribute('aria-hidden','true'); }
  if (v === 'crawl') { title.style.display='none'; crawl.style.opacity=1; overlay.setAttribute('aria-hidden','true'); }
  if (v === 'precount') { title.style.display='none'; crawl.style.opacity=0; overlay.setAttribute('aria-hidden','false'); }
  if (v === 'main') { overlay.setAttribute('aria-hidden','true'); }
  if (v === 'final') { overlay.setAttribute('aria-hidden','true'); }
  if (v === 'victory') { overlay.setAttribute('aria-hidden','true'); }
}

/* ===========================
   UPDATE (game logic)
   =========================== */
function perfTime(){ return performance.now()/1000; }

function update(dt) {
  // clamp dt to avoid jumps after suspension
  dt = clamp(dt, 0, 0.05);
  // update pools
  updatePools(dt);
  // update star twinkle
  for (let s of STARS) s.twinkle += dt*0.6;
  // main session deterministic drain
  if (STATE.view === 'main' && STATE.mainStarted) {
    const drain = STATE.drainPerSecond * dt;
    STATE.bossHP = Math.max(0, STATE.bossHP - drain);
    // when bossHP reaches zero, trigger final cinematic
    if (STATE.bossHP <= 0 && !STATE.finalStarted) {
      STATE.bossHP = 0;
      startFinalCinematic();
    }
    // update timer
    STATE.time += dt;
    const remaining = Math.max(0, CONFIG.duration - STATE.time);
    updateTimerDisplay(remaining);
    // camera dolly zoom when HP < 30%
    if (!CONFIG.reducedMotion && (STATE.bossHP / CONFIG.bossMaxHP) < 0.3) {
      // subtle effect handled in render via global scale
    }
  }
}

/* update timer UI */
function updateTimerDisplay(remaining) {
  const mm = Math.floor(remaining/60);
  const ss = Math.floor(remaining%60);
  const s = `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
  document.getElementById('timer').textContent = s;
  document.getElementById('timer').setAttribute('aria-label', `Chrono Sync Timer ${s}`);
  // boss bar percent
  const pct = Math.round((STATE.bossHP / CONFIG.bossMaxHP)*100);
  document.getElementById('bossFill').style.width = `${pct}%`;
  document.getElementById('bossBar').setAttribute('aria-valuenow', String(pct));
  document.getElementById('bossLabel').textContent = pct>0 ? `TITAN OMEGA CORE ${pct}%` : 'TITAN OMEGA CORE';
}

/* ===========================
   RENDER (drawing)
   =========================== */
function render() {
  // clear
  ctx.fillStyle = CONFIG.canvasBg || '#020617';
  ctx.fillRect(0,0,CONFIG.canvasW,CONFIG.canvasH);

  // camera dolly zoom when HP low
  let camScale = 1;
  if (!CONFIG.reducedMotion && STATE.view === 'main' && STATE.bossHP / CONFIG.bossMaxHP < 0.3) {
    const t = clamp((1 - STATE.bossHP/CONFIG.bossMaxHP), 0, 1);
    camScale = lerp(1, 1.06, Math.min(1, t*0.6));
  }

  ctx.save();
  // center transform for dolly
  ctx.translate(CONFIG.canvasW/2, CONFIG.canvasH/2);
  ctx.scale(camScale, camScale);
  ctx.translate(-CONFIG.canvasW/2, -CONFIG.canvasH/2);

  // starfield parallax
  for (let s of STARS) {
    const sx = (s.x + (perfTime()*10*(1/s.z))) % CONFIG.canvasW;
    const sy = (s.y + Math.sin(perfTime()*0.2 + s.z)*6) % CONFIG.canvasH;
    const r = 0.6 * (1/s.z);
    ctx.fillStyle = `rgba(255,255,255,${0.6*Math.abs(Math.sin(s.twinkle))})`;
    ctx.fillRect(sx, sy, r, r);
  }

  // distant debris (small)
  const dpool = STATE.pools.debris;
  for (let it of dpool.items) {
    if (!it.active) continue;
    ctx.save();
    ctx.translate(it.x, it.y);
    ctx.rotate(it.rot);
    ctx.fillStyle = it.color;
    ctx.fillRect(-it.size/2, -it.size/2, it.size, it.size*0.6);
    ctx.restore();
  }

  // Titan
  const hpFrac = STATE.bossHP / CONFIG.bossMaxHP;
  drawTitan(ctx, hpFrac);

  // hero
  drawHero(ctx);

  // particles
  const ppool = STATE.pools.particles;
  for (let it of ppool.items) {
    if (!it.active) continue;
    ctx.fillStyle = it.color;
    ctx.globalAlpha = 1 - (it.life/it.ttl);
    ctx.beginPath(); ctx.arc(it.x, it.y, it.size, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  // HUD overlays like progress ring (simple)
  // progress ring around timer
  const cx = CONFIG.canvasW/2, cy = CONFIG.canvasH*0.55;
  const radius = 48;
  ctx.beginPath();
  ctx.lineWidth = 6;
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.arc(cx, cy, radius, 0, Math.PI*2);
  ctx.stroke();
  // progress arc
  const prog = STATE.view === 'main' ? clamp(STATE.time/CONFIG.duration, 0, 1) : 0;
  ctx.beginPath();
  ctx.strokeStyle = `rgba(0,240,255,0.9)`;
  ctx.lineWidth = 6;
  ctx.arc(cx, cy, radius, -Math.PI/2, -Math.PI/2 + Math.PI*2*prog);
  ctx.stroke();

  ctx.restore();

  // film grain compositing
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.drawImage(grainCanvas, 0, 0);
  ctx.globalAlpha = 0.08;
  ctx.drawImage(halftoneCanvas, 0, 0);
  ctx.restore();

  // scanlines overlay via DOM element already present
}

/* grain & halftone generation */
function updateGrain() {
  const g = grainCtx;
  const w = CONFIG.canvasW, h = CONFIG.canvasH;
  const img = g.createImageData(w, h);
  const d = img.data;
  for (let i=0;i<d.length;i+=4){
    const v = Math.floor(Math.random()*255);
    d[i]=d[i+1]=d[i+2]=v;
    d[i+3]=255;
  }
  g.putImageData(img,0,0);
  // halftone: large dot pattern
  const hc = halftoneCtx;
  hc.clearRect(0,0,w,h);
  hc.fillStyle = 'rgba(255,255,255,0.06)';
  const spacing = 12;
  for (let y=0;y<h;y+=spacing){
    for (let x=0;x<w;x+=spacing){
      const r = 2 + Math.random()*4;
      hc.beginPath(); hc.arc(x+ (y%24?6:0), y, r, 0, Math.PI*2); hc.fill();
    }
  }
}

/* film scratches & rivets overlay (drawn onto main canvas occasionally) */
function drawScratches(ctx) {
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for (let i=0;i<6;i++){
    const y = Math.random()*CONFIG.canvasH;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(CONFIG.canvasW, y + rand(-6,6)); ctx.stroke();
  }
  ctx.restore();
}

/* ===========================
   LOOP
   =========================== */
let looping = false;
let lastGrain = 0;
function loop(t) {
  looping = true;
  const nowt = now();
  if (!STATE.lastTime) STATE.lastTime = nowt;
  let dt = nowt - STATE.lastTime;
  STATE.lastTime = nowt;
  // clamp dt
  dt = clamp(dt, 0, 0.05);
  // update
  if (STATE.running || STATE.view !== 'main') update(dt);
  // render
  render();
  // occasional grain update at ~CONFIG.grainHz
  if (nowt - lastGrain > 1/CONFIG.grainHz) { updateGrain(); lastGrain = nowt; }
  // film scratches occasionally
  if (Math.random() < 0.02) drawScratches(ctx);
  requestAnimationFrame(loop);
}

/* start loop */
requestAnimationFrame(loop);

/* ===========================
   DEBUG HOOKS & EXPORTS
   =========================== */
window.__TITAN = {
  get state() { return STATE; },
  startGame: ()=> startPrologue(),
  setView: (v)=> setView(v),
  forceVictory: ()=> {
    STATE.bossHP = 0;
    startFinalCinematic();
  }
};

/* ===========================
   HELPERS & UTIL
   =========================== */
function hexToRgba(hex, a=1) {
  hex = hex.replace('#','');
  const r = parseInt(hex.substring(0,2),16);
  const g = parseInt(hex.substring(2,4),16);
  const b = parseInt(hex.substring(4,6),16);
  return `rgba(${r},${g},${b},${a})`;
}

/* ===========================
   Acceptance: ensure persistence keys exist
   =========================== */
localStorage.setItem(CONFIG.storageKeys.crystals, String(STATE.crystals));
localStorage.setItem(CONFIG.storageKeys.streak, String(STATE.streak));
localStorage.setItem(CONFIG.storageKeys.best, String(STATE.best));
localStorage.setItem(CONFIG.storageKeys.pilot, STATE.pilot || '');
localStorage.setItem(CONFIG.storageKeys.mute, STATE.audioMuted ? '1' : '0');

/* ===========================
   Inline comments for drain logic (developer hint)
   =========================== */
// drainPerSecond = bossMaxHP / duration;
// bossHP -= drainPerSecond * dt;
// clamp dt to avoid jumps after suspension (dt = clamp(dt, 0, 0.05))

/* ===========================
   Final small accessibility & iOS home screen notes
   =========================== */
// Attach event listeners on DOMContentLoaded (done above).
// Resume AudioContext on first touchend/click (resumeAudioOnFirstTouch).
// ARIA labels added for timer and boss health.
// No scrolling; layout fits safe area insets.

</script>
</body>
</html>
