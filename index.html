<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Brush Hero: Robo Boss Battle</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no" />
<style>
  :root {
    --bg: #050814;
    --accent: #4af2a1;
    --accent2: #ff4f7b;
    --hud-bg: #0b1024;
    --hud-border: #4af2a1;
    --text-main: #f5f7ff;
    --text-soft: #9aa4d4;
    --warning: #ffcc33;
    --danger: #ff3366;
    --pixel-font: "Press Start 2P", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  @font-face {
    font-family: "Press Start 2P";
    src: local("Press Start 2P"),
         url("https://fonts.gstatic.com/s/pressstart2p/v11/e3t4euO8T-267oIAQAu6jDQyK3nVivY.woff2") format("woff2");
  }

  * {
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }

  html, body {
    margin: 0;
    padding: 0;
    background: radial-gradient(circle at top, #151b3a 0, #050814 55%, #02030a 100%);
    color: var(--text-main);
    font-family: var(--pixel-font);
    height: 100%;
    overflow: hidden;
  }

  body {
    display: flex;
    justify-content: center;
    align-items: stretch;
  }

  #app {
    width: 100vw;
    height: 100vh;
    max-width: 480px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    padding: 8px;
    gap: 6px;
  }

  /* HUD */
  .hud {
    display: grid;
    grid-template-columns: 1.3fr 1fr;
    grid-template-rows: auto auto;
    gap: 4px;
    padding: 6px;
    border-radius: 10px;
    border: 2px solid var(--hud-border);
    background: linear-gradient(135deg, rgba(10,18,40,0.95), rgba(5,8,20,0.98));
    box-shadow: 0 0 12px rgba(74,242,161,0.25);
    position: relative;
  }

  .hud-left {
    grid-row: 1 / span 2;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .hud-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 9px;
    letter-spacing: 0.05em;
    color: var(--text-soft);
  }

  .hud-row strong {
    color: var(--accent);
  }

  .timer-display {
    font-size: 20px;
    color: var(--text-main);
    text-shadow: 0 0 6px rgba(255,255,255,0.6);
  }

  .zone-label {
    font-size: 9px;
    text-transform: uppercase;
    color: var(--accent2);
  }

  .streak-display {
    font-size: 9px;
  }

  .crystals-display {
    font-size: 9px;
    color: var(--accent);
  }

  .start-btn {
    grid-column: 2 / 3;
    grid-row: 1 / 2;
    align-self: stretch;
    justify-self: stretch;
    border-radius: 10px;
    border: 2px solid var(--accent2);
    background: radial-gradient(circle at 20% 0, #ff9fd0 0, #ff4f7b 40%, #7b1b3a 100%);
    color: #fff;
    font-family: var(--pixel-font);
    font-size: 11px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    cursor: pointer;
    box-shadow: 0 0 12px rgba(255,79,123,0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 4px;
  }

  .start-btn:active {
    transform: translateY(1px);
    box-shadow: 0 0 6px rgba(255,79,123,0.4);
  }

  .status-chip {
    grid-column: 2 / 3;
    grid-row: 2 / 3;
    align-self: stretch;
    justify-self: stretch;
    border-radius: 8px;
    border: 1px solid rgba(148,163,255,0.5);
    background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(30,64,175,0.7));
    font-size: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-soft);
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  .status-chip span {
    color: var(--accent);
  }

  /* Canvas container */
  .canvas-wrap {
    flex: 1;
    border-radius: 12px;
    border: 2px solid rgba(74,242,161,0.4);
    background: radial-gradient(circle at top, #1b2348 0, #050814 60%, #02030a 100%);
    overflow: hidden;
    position: relative;
  }

  #gameCanvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  /* Scanline / glow overlay */
  .canvas-overlay {
    pointer-events: none;
    position: absolute;
    inset: 0;
    background-image:
      linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
      radial-gradient(circle at top, rgba(74,242,161,0.15), transparent 55%);
    background-size: 100% 3px, 100% 100%;
    mix-blend-mode: screen;
  }

  /* Loot box modal */
  .modal {
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at center, rgba(5,8,20,0.95), rgba(0,0,0,0.98));
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 20;
  }

  .modal-inner {
    width: 85%;
    max-width: 360px;
    border-radius: 14px;
    border: 2px solid var(--accent);
    background: linear-gradient(145deg, #050814, #10152b);
    padding: 14px;
    box-shadow: 0 0 18px rgba(74,242,161,0.5);
    text-align: center;
  }

  .modal-title {
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--accent);
    margin-bottom: 8px;
  }

  .loot-box {
    margin: 10px auto;
    width: 120px;
    height: 80px;
    border-radius: 10px;
    border: 3px solid var(--accent2);
    background: linear-gradient(145deg, #3b0b2a, #ff4f7b);
    position: relative;
    cursor: pointer;
    box-shadow: 0 0 16px rgba(255,79,123,0.7);
  }

  .loot-box::before,
  .loot-box::after {
    content: "";
    position: absolute;
    inset: 8px;
    border-radius: 6px;
    border: 2px dashed rgba(255,255,255,0.6);
  }

  .loot-box::after {
    inset: 18px 30px;
    border-style: solid;
    border-color: rgba(255,255,255,0.9);
  }

  .loot-label {
    position: absolute;
    bottom: 6px;
    left: 0;
    right: 0;
    font-size: 8px;
    text-transform: uppercase;
    letter-spacing: 0.12em;
  }

  .loot-glow {
    position: absolute;
    inset: -8px;
    border-radius: 14px;
    background: radial-gradient(circle at center, rgba(255,255,255,0.4), transparent 60%);
    opacity: 0;
    pointer-events: none;
  }

  .loot-box.opened .loot-glow {
    animation: lootGlow 1.2s ease-out forwards;
  }

  @keyframes lootGlow {
    0% { opacity: 0; transform: scale(0.7); }
    40% { opacity: 1; transform: scale(1.05); }
    100% { opacity: 0; transform: scale(1.2); }
  }

  .loot-stats {
    margin-top: 10px;
    font-size: 9px;
    color: var(--text-soft);
  }

  .loot-stats strong {
    color: var(--accent);
  }

  .modal-close {
    margin-top: 10px;
    border-radius: 10px;
    border: 1px solid var(--accent);
    background: rgba(15,23,42,0.9);
    color: var(--text-main);
    font-family: var(--pixel-font);
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    padding: 6px 10px;
    cursor: pointer;
  }

  /* Parent / passcode */
  .parent-toggle {
    position: absolute;
    bottom: 4px;
    right: 6px;
    font-size: 7px;
    color: rgba(148,163,255,0.5);
    text-transform: uppercase;
    letter-spacing: 0.12em;
    cursor: pointer;
    user-select: none;
  }

  .parent-panel {
    position: absolute;
    bottom: 4px;
    left: 4px;
    right: 4px;
    border-radius: 10px;
    border: 1px solid rgba(148,163,255,0.7);
    background: rgba(15,23,42,0.96);
    padding: 6px;
    font-size: 8px;
    display: none;
    z-index: 15;
  }

  .parent-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 4px;
    gap: 4px;
  }

  .parent-row label {
    flex: 1;
  }

  .parent-row input {
    flex: 1;
    padding: 2px 4px;
    border-radius: 6px;
    border: 1px solid rgba(148,163,255,0.7);
    background: #020617;
    color: var(--text-main);
    font-family: var(--pixel-font);
    font-size: 8px;
  }

  .parent-row input[type="number"] {
    -moz-appearance: textfield;
  }
  .parent-row input::-webkit-outer-spin-button,
  .parent-row input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .parent-actions {
    display: flex;
    justify-content: flex-end;
    gap: 4px;
  }

  .parent-btn {
    border-radius: 8px;
    border: 1px solid rgba(74,242,161,0.7);
    background: rgba(15,23,42,0.9);
    color: var(--accent);
    font-family: var(--pixel-font);
    font-size: 8px;
    padding: 3px 6px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    cursor: pointer;
  }

  .parent-warning {
    font-size: 7px;
    color: var(--warning);
    margin-bottom: 4px;
  }

  .passcode-row {
    margin-bottom: 4px;
  }

  .passcode-row input {
    width: 60px;
  }

  .error-msg {
    font-size: 7px;
    color: var(--danger);
    min-height: 10px;
  }

  /* Timer flash */
  .timer-flash {
    animation: timerFlash 0.4s alternate infinite;
  }

  @keyframes timerFlash {
    from { color: var(--danger); text-shadow: 0 0 4px rgba(255,51,102,0.7); }
    to { color: #fff; text-shadow: 0 0 8px rgba(255,255,255,1); }
  }

  .hud-warning {
    animation: hudWarning 0.4s alternate infinite;
  }

  @keyframes hudWarning {
    from { border-color: var(--danger); box-shadow: 0 0 10px rgba(255,51,102,0.7); }
    to { border-color: var(--accent2); box-shadow: 0 0 4px rgba(255,79,123,0.4); }
  }
</style>
</head>
<body>
<div id="app">
  <div class="hud" id="hud">
    <div class="hud-left">
      <div class="hud-row">
        <div>
          <div class="zone-label" id="zoneLabel">ZONE 1 路 BATHROOM BASE</div>
          <div class="timer-display" id="timerDisplay">02:00</div>
        </div>
        <div class="streak-display">
          Streak: <strong id="streakValue">0</strong><br />
          Days: <strong id="daysValue">0</strong>
        </div>
      </div>
      <div class="hud-row">
        <div class="crystals-display">
          Crystals: <strong id="crystalsValue">0</strong>
        </div>
        <div style="font-size:8px;color:var(--text-soft);text-align:right;">
          Boss HP: <span id="bossHpLabel">100%</span>
        </div>
      </div>
    </div>
    <button class="start-btn" id="startButton">START BRUSH</button>
    <div class="status-chip" id="statusChip">
      STATUS: <span>&nbsp;READY</span>
    </div>
  </div>

  <div class="canvas-wrap">
    <canvas id="gameCanvas"></canvas>
    <div class="canvas-overlay"></div>

    <div class="modal" id="lootModal">
      <div class="modal-inner">
        <div class="modal-title">LOOT CRATE UNLOCKED</div>
        <div style="font-size:9px;color:var(--text-soft);margin-bottom:6px;">
          Great brushing! Tap the crate to reveal your crystals.
        </div>
        <div class="loot-box" id="lootBox">
          <div class="loot-glow"></div>
          <div class="loot-label">TAP TO OPEN</div>
        </div>
        <div class="loot-stats" id="lootStats" style="display:none;">
          Run crystals: <strong id="runCrystals">0</strong><br />
          Total crystals: <strong id="totalCrystals">0</strong><br />
          Streak: <strong id="modalStreak">0</strong> 路 Days: <strong id="modalDays">0</strong>
        </div>
        <button class="modal-close" id="closeModalBtn" style="display:none;">OK 路 BACK TO BASE</button>
      </div>
    </div>

    <div class="parent-toggle" id="parentToggle">PARENT</div>
    <div class="parent-panel" id="parentPanel">
      <div class="parent-warning">
        Parent controls 路 adjust streak, days, and crystals. Changes are saved on this device only.
      </div>
      <div class="passcode-row parent-row">
        <label for="passcodeInput">Passcode</label>
        <input type="password" id="passcodeInput" maxlength="4" inputmode="numeric" />
      </div>
      <div class="parent-row">
        <label for="streakInput">Streak</label>
        <input type="number" id="streakInput" min="0" />
      </div>
      <div class="parent-row">
        <label for="daysInput">Days brushed</label>
        <input type="number" id="daysInput" min="0" />
      </div>
      <div class="parent-row">
        <label for="crystalsInput">Crystals</label>
        <input type="number" id="crystalsInput" min="0" />
      </div>
      <div class="error-msg" id="parentError"></div>
      <div class="parent-actions">
        <button class="parent-btn" id="parentCancel">Close</button>
        <button class="parent-btn" id="parentSave">Save</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------- Persistent state ---------- */
const STORAGE_KEY = "brushHeroProgress_v1";
const DEFAULT_PROGRESS = {
  streak: 0,
  days: 0,
  crystals: 0,
  lastBrushDate: null
};

let progress = loadProgress();

/* ---------- DOM refs ---------- */
const timerDisplay = document.getElementById("timerDisplay");
const streakValue = document.getElementById("streakValue");
const daysValue = document.getElementById("daysValue");
const crystalsValue = document.getElementById("crystalsValue");
const bossHpLabel = document.getElementById("bossHpLabel");
const startButton = document.getElementById("startButton");
const statusChip = document.getElementById("statusChip");
const hud = document.getElementById("hud");

const lootModal = document.getElementById("lootModal");
const lootBox = document.getElementById("lootBox");
const lootStats = document.getElementById("lootStats");
const runCrystalsEl = document.getElementById("runCrystals");
const totalCrystalsEl = document.getElementById("totalCrystals");
const modalStreakEl = document.getElementById("modalStreak");
const modalDaysEl = document.getElementById("modalDays");
const closeModalBtn = document.getElementById("closeModalBtn");

const parentToggle = document.getElementById("parentToggle");
const parentPanel = document.getElementById("parentPanel");
const passcodeInput = document.getElementById("passcodeInput");
const streakInput = document.getElementById("streakInput");
const daysInput = document.getElementById("daysInput");
const crystalsInput = document.getElementById("crystalsInput");
const parentError = document.getElementById("parentError");
const parentCancel = document.getElementById("parentCancel");
const parentSave = document.getElementById("parentSave");

/* ---------- Audio (simple beep) ---------- */
let audioCtx = null;
function playBeep() {
  try {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    const duration = 0.12;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "square";
    osc.frequency.value = 880;
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  } catch (e) {
    // Safari may block; fail silently
  }
}

/* ---------- Timer / game state ---------- */
const PRE_COUNTDOWN = 5;      // seconds before brushing
const BRUSH_DURATION = 120;   // 2 minutes
const BOSS_MAX_HP = 100;
const BOSS_DAMAGE_INTERVAL = 30; // seconds
const BOSS_DAMAGE_AMOUNT = BOSS_MAX_HP / (BRUSH_DURATION / BOSS_DAMAGE_INTERVAL);

let gameState = "idle"; // idle | pre | running | finished
let preCountdownRemaining = PRE_COUNTDOWN;
let brushRemaining = BRUSH_DURATION;
let lastTickTime = null;
let bossHp = BOSS_MAX_HP;
let lastBossDamageTime = 0;
let lastSecond = null;
let flashActive = false;

/* ---------- Canvas setup ---------- */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d", { alpha: false });

function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/* ---------- Simple pixel-art hero/boss/particles ---------- */
const hero = {
  x: 40,
  y: 0,
  baseY: 0,
  width: 24,
  height: 28,
  dir: 1,
  walkSpeed: 40,
  jumpTimer: 0,
  attackTimer: 0
};

const boss = {
  x: 0,
  y: 0,
  width: 60,
  height: 60,
  expression: "idle", // idle | hurt | angry
  expressionTimer: 0
};

const particles = [];

function spawnHitParticles(x, y, color) {
  for (let i = 0; i < 10; i++) {
    particles.push({
      x,
      y,
      vx: (Math.random() - 0.5) * 80,
      vy: -40 - Math.random() * 40,
      life: 0.4 + Math.random() * 0.3,
      age: 0,
      color
    });
  }
}

/* ---------- Drawing helpers ---------- */
function drawBackground() {
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  // Parallax stripes
  ctx.fillStyle = "#050814";
  ctx.fillRect(0, 0, w, h);

  const gradient = ctx.createLinearGradient(0, 0, w, h);
  gradient.addColorStop(0, "#151b3a");
  gradient.addColorStop(0.5, "#050814");
  gradient.addColorStop(1, "#02030a");
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, w, h);

  // Horizon grid
  ctx.strokeStyle = "rgba(74,242,161,0.25)";
  ctx.lineWidth = 1;
  const baseY = h * 0.7;
  ctx.beginPath();
  ctx.moveTo(0, baseY);
  ctx.lineTo(w, baseY);
  ctx.stroke();

  ctx.save();
  ctx.translate(0, baseY);
  for (let i = 1; i < 10; i++) {
    const y = i * 14;
    ctx.globalAlpha = 1 - i * 0.08;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(w, y);
    ctx.stroke();
  }
  ctx.restore();

  // Vertical grid lines
  ctx.globalAlpha = 0.25;
  for (let x = 0; x < w; x += 20) {
    ctx.beginPath();
    ctx.moveTo(x, baseY);
    ctx.lineTo(x + 40, h);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Stars
  ctx.fillStyle = "rgba(148,163,255,0.7)";
  for (let i = 0; i < 40; i++) {
    const sx = (i * 37) % w;
    const sy = (i * 53) % (h * 0.4);
    ctx.fillRect(sx, sy, 1, 1);
  }
}

function drawHero(dt) {
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  const groundY = h * 0.7;

  hero.baseY = groundY - hero.height;
  hero.y = hero.baseY;

  // Auto movement
  hero.x += hero.walkSpeed * hero.dir * dt;
  if (hero.x < 20) {
    hero.x = 20;
    hero.dir = 1;
  } else if (hero.x > w * 0.5) {
    hero.x = w * 0.5;
    hero.dir = -1;
  }

  // Jump occasionally
  if (hero.jumpTimer <= 0 && Math.random() < 0.01) {
    hero.jumpTimer = 0.6;
  }
  if (hero.jumpTimer > 0) {
    hero.jumpTimer -= dt;
    const t = hero.jumpTimer;
    const jumpHeight = 18;
    hero.y = hero.baseY - Math.sin((1 - t / 0.6) * Math.PI) * jumpHeight;
  }

  // Attack occasionally
  if (hero.attackTimer <= 0 && Math.random() < 0.02) {
    hero.attackTimer = 0.35;
    spawnHitParticles(boss.x + boss.width / 2, boss.y + boss.height / 2, "#ffcc66");
    boss.expression = "hurt";
    boss.expressionTimer = 0.25;
  }
  if (hero.attackTimer > 0) {
    hero.attackTimer -= dt;
  }

  // Draw hero body (simple pixel robot)
  ctx.save();
  ctx.translate(hero.x, hero.y);

  // Shadow
  ctx.fillStyle = "rgba(0,0,0,0.4)";
  ctx.beginPath();
  ctx.ellipse(0, hero.height + 4, 10, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Body
  ctx.fillStyle = "#4af2a1";
  ctx.fillRect(-8, 4, 16, 16);

  // Head
  ctx.fillStyle = "#1f2937";
  ctx.fillRect(-7, -6, 14, 10);
  ctx.fillStyle = "#4af2a1";
  ctx.fillRect(-6, -5, 12, 8);

  // Eyes
  ctx.fillStyle = "#050814";
  ctx.fillRect(-4, -3, 3, 3);
  ctx.fillRect(1, -3, 3, 3);

  // Arms
  ctx.fillStyle = "#4af2a1";
  const armOffset = hero.attackTimer > 0 ? 4 : 0;
  ctx.fillRect(-12, 6, 4, 10);
  ctx.fillRect(8, 6 - armOffset, 4, 10 + armOffset);

  // Legs (simple walk animation)
  const legPhase = Math.sin(Date.now() / 120);
  ctx.fillRect(-6, 20, 4, 8 + legPhase * 2);
  ctx.fillRect(2, 20, 4, 8 - legPhase * 2);

  ctx.restore();
}

function drawBoss(dt) {
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  boss.x = w * 0.65;
  boss.y = h * 0.45 - boss.height;

  // Expression timer
  if (boss.expressionTimer > 0) {
    boss.expressionTimer -= dt;
    if (boss.expressionTimer <= 0) {
      boss.expression = bossHp <= 0 ? "defeated" : (bossHp < 40 ? "angry" : "idle");
    }
  }

  // Boss body
  ctx.save();
  ctx.translate(boss.x, boss.y);

  // Glow
  ctx.fillStyle = "rgba(255,79,123,0.25)";
  ctx.beginPath();
  ctx.ellipse(boss.width / 2, boss.height + 10, 26, 8, 0, 0, Math.PI * 2);
  ctx.fill();

  // Main body
  const hpRatio = Math.max(0, bossHp) / BOSS_MAX_HP;
  const bodyColor = hpRatio > 0.6 ? "#ff4f7b" : hpRatio > 0.3 ? "#ff9f43" : "#ffcc33";
  ctx.fillStyle = bodyColor;
  ctx.fillRect(0, 0, boss.width, boss.height);

  // Face panel
  ctx.fillStyle = "#050814";
  ctx.fillRect(8, 10, boss.width - 16, 24);

  // Eyes / mouth based on expression
  ctx.fillStyle = "#4af2a1";
  if (boss.expression === "idle") {
    ctx.fillRect(12, 14, 6, 4);
    ctx.fillRect(boss.width - 18, 14, 6, 4);
    ctx.fillRect(18, 24, boss.width - 36, 3);
  } else if (boss.expression === "hurt") {
    ctx.fillRect(12, 14, 6, 2);
    ctx.fillRect(boss.width - 18, 14, 6, 2);
    ctx.fillRect(18, 26, boss.width - 36, 2);
  } else if (boss.expression === "angry") {
    ctx.fillRect(12, 14, 6, 4);
    ctx.fillRect(boss.width - 18, 14, 6, 4);
    ctx.fillRect(18, 26, boss.width - 36, 2);
    ctx.fillStyle = "#ff3366";
    ctx.fillRect(12, 18, 6, 2);
    ctx.fillRect(boss.width - 18, 18, 6, 2);
  } else if (boss.expression === "defeated") {
    ctx.fillStyle = "#9ca3af";
    ctx.fillRect(12, 16, 6, 2);
    ctx.fillRect(boss.width - 18, 16, 6, 2);
    ctx.fillRect(18, 26, boss.width - 36, 2);
  }

  // Antenna
  ctx.fillStyle = "#f97316";
  ctx.fillRect(boss.width / 2 - 1, -8, 2, 8);
  ctx.fillStyle = "#facc15";
  ctx.fillRect(boss.width / 2 - 3, -12, 6, 4);

  // Side arms
  ctx.fillStyle = bodyColor;
  ctx.fillRect(-8, 18, 8, 18);
  ctx.fillRect(boss.width, 18, 8, 18);

  ctx.restore();
}

function drawParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.age += dt;
    if (p.age >= p.life) {
      particles.splice(i, 1);
      continue;
    }
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 120 * dt;

    const t = 1 - p.age / p.life;
    ctx.globalAlpha = t;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, 2, 2);
    ctx.globalAlpha = 1;
  }
}

/* ---------- Game loop ---------- */
function updateTimer(delta) {
  if (gameState === "pre") {
    preCountdownRemaining -= delta;
    if (preCountdownRemaining <= 0) {
      gameState = "running";
      brushRemaining = BRUSH_DURATION;
      preCountdownRemaining = 0;
      statusChip.innerHTML = 'STATUS: <span>&nbsp;BRUSH!</span>';
    }
  } else if (gameState === "running") {
    brushRemaining -= delta;
    if (brushRemaining <= 0) {
      brushRemaining = 0;
      finishRun();
    }
  }
}

function updateBossDamage(delta) {
  if (gameState !== "running") return;
  lastBossDamageTime += delta;
  if (lastBossDamageTime >= BOSS_DAMAGE_INTERVAL) {
    lastBossDamageTime -= BOSS_DAMAGE_INTERVAL;
    bossHp -= BOSS_DAMAGE_AMOUNT;
    bossHp = Math.max(0, bossHp);
    bossHpLabel.textContent = Math.round((bossHp / BOSS_MAX_HP) * 100) + "%";
    boss.expression = bossHp <= 0 ? "defeated" : "hurt";
    boss.expressionTimer = 0.4;
    spawnHitParticles(boss.x + boss.width / 2, boss.y + boss.height / 2, "#ffcc66");
  }
}

function updateFlash() {
  const remaining = gameState === "pre" ? preCountdownRemaining : brushRemaining;
  const total = gameState === "pre" ? PRE_COUNTDOWN : BRUSH_DURATION;
  const secondsLeft = Math.ceil(remaining);

  // Last 10 seconds of brushing: flash + beep each second
  if (gameState === "running" && secondsLeft <= 10 && secondsLeft >= 0) {
    if (!flashActive) {
      hud.classList.add("hud-warning");
      timerDisplay.classList.add("timer-flash");
      flashActive = true;
    }
    if (lastSecond !== secondsLeft) {
      playBeep();
    }
  } else {
    if (flashActive) {
      hud.classList.remove("hud-warning");
      timerDisplay.classList.remove("timer-flash");
      flashActive = false;
    }
  }

  // Update display text
  if (gameState === "pre") {
    timerDisplay.textContent = "GET READY " + secondsLeft;
  } else {
    const m = Math.floor(brushRemaining / 60);
    const s = Math.floor(brushRemaining % 60);
    timerDisplay.textContent =
      String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
  }

  lastSecond = secondsLeft;
}

function gameLoop(timestamp) {
  if (!lastTickTime) lastTickTime = timestamp;
  const delta = (timestamp - lastTickTime) / 1000;
  lastTickTime = timestamp;

  updateTimer(delta);
  updateBossDamage(delta);

  drawBackground();
  drawHero(delta);
  drawBoss(delta);
  drawParticles(delta);
  updateFlash();

  requestAnimationFrame(gameLoop);
}

/* ---------- Run completion / rewards ---------- */
function finishRun() {
  if (gameState === "finished") return;
  gameState = "finished";
  statusChip.innerHTML = 'STATUS: <span>&nbsp;COMPLETE</span>';

  // Update progress: streak, days, crystals
  const today = new Date();
  const todayKey = today.toISOString().slice(0, 10);
  let newDay = false;

  if (!progress.lastBrushDate) {
    progress.streak = 1;
    progress.days = 1;
    newDay = true;
  } else {
    if (progress.lastBrushDate === todayKey) {
      // Same day: keep streak, don't increment days
    } else {
      const last = new Date(progress.lastBrushDate);
      const diffDays = Math.round((today - last) / (1000 * 60 * 60 * 24));
      if (diffDays === 1) {
        progress.streak += 1;
      } else {
        progress.streak = 1;
      }
      progress.days += 1;
      newDay = true;
    }
  }

  progress.lastBrushDate = todayKey;

  // Crystals: base + streak bonus
  const baseCrystals = 10;
  const streakBonus = Math.min(progress.streak * 2, 40);
  const runCrystals = baseCrystals + streakBonus;
  progress.crystals += runCrystals;

  saveProgress();

  // Update HUD
  streakValue.textContent = progress.streak;
  daysValue.textContent = progress.days;
  crystalsValue.textContent = progress.crystals;

  // Show loot modal
  showLootModal(runCrystals);
}

function showLootModal(runCrystals) {
  lootModal.style.display = "flex";
  lootStats.style.display = "none";
  closeModalBtn.style.display = "none";
  lootBox.classList.remove("opened");
  runCrystalsEl.textContent = runCrystals;
  totalCrystalsEl.textContent = progress.crystals;
  modalStreakEl.textContent = progress.streak;
  modalDaysEl.textContent = progress.days;
}

/* ---------- Storage helpers ---------- */
function loadProgress() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return { ...DEFAULT_PROGRESS };
    const parsed = JSON.parse(raw);
    return { ...DEFAULT_PROGRESS, ...parsed };
  } catch (e) {
    return { ...DEFAULT_PROGRESS };
  }
}

function saveProgress() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
  } catch (e) {
    // ignore
  }
}

function refreshHudFromProgress() {
  streakValue.textContent = progress.streak;
  daysValue.textContent = progress.days;
  crystalsValue.textContent = progress.crystals;
}
refreshHudFromProgress();

/* ---------- Parent controls ---------- */
const PARENT_PASSCODE = "1978"; // simple 4-digit code

let parentVisible = false;
function toggleParentPanel() {
  parentVisible = !parentVisible;
  parentPanel.style.display = parentVisible ? "block" : "none";
  parentError.textContent = "";
  if (parentVisible) {
    passcodeInput.value = "";
    streakInput.value = progress.streak;
    daysInput.value = progress.days;
    crystalsInput.value = progress.crystals;
  }
}

parentToggle.addEventListener("click", () => {
  toggleParentPanel();
});

parentCancel.addEventListener("click", () => {
  toggleParentPanel();
});

parentSave.addEventListener("click", () => {
  const code = passcodeInput.value.trim();
  if (code !== PARENT_PASSCODE) {
    parentError.textContent = "Incorrect passcode.";
    return;
  }
  const s = parseInt(streakInput.value, 10);
  const d = parseInt(daysInput.value, 10);
  const c = parseInt(crystalsInput.value, 10);
  if (Number.isNaN(s) || Number.isNaN(d) || Number.isNaN(c)) {
    parentError.textContent = "Please enter valid numbers.";
    return;
  }
  progress.streak = Math.max(0, s);
  progress.days = Math.max(0, d);
  progress.crystals = Math.max(0, c);
  saveProgress();
  refreshHudFromProgress();
  parentError.textContent = "Saved.";
  setTimeout(() => toggleParentPanel(), 600);
});

/* ---------- Start button ---------- */
startButton.addEventListener("click", () => {
  if (gameState === "pre" || gameState === "running") return;

  // Reset state
  gameState = "pre";
  preCountdownRemaining = PRE_COUNTDOWN;
  brushRemaining = BRUSH_DURATION;
  bossHp = BOSS_MAX_HP;
  bossHpLabel.textContent = "100%";
  lastBossDamageTime = 0;
  lastSecond = null;
  statusChip.innerHTML = 'STATUS: <span>&nbsp;GET READY</span>';
  hud.classList.remove("hud-warning");
  timerDisplay.classList.remove("timer-flash");
  flashActive = false;

  // Small beep to confirm start (user interaction present)
  playBeep();
});

/* ---------- Loot modal interactions ---------- */
lootBox.addEventListener("click", () => {
  lootBox.classList.add("opened");
  lootStats.style.display = "block";
  closeModalBtn.style.display = "inline-block";
});

closeModalBtn.addEventListener("click", () => {
  lootModal.style.display = "none";
  gameState = "idle";
  statusChip.innerHTML = 'STATUS: <span>&nbsp;READY</span>';
  timerDisplay.textContent = "02:00";
});

/* ---------- Kick off loop ---------- */
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
