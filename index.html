<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>TITAN OMEGA â€” CHRONO SYNC (Toothbrush Mode)</title>
<style>
  /* Global layout: no scroll, respect safe area insets */
  :root{
    --bg:#07102a;
    --neon:#00f0ff;
    --pink:#ff3fb5;
    --accent:#7afcff;
    --crt: rgba(255,255,255,0.03);
    --ui-bg: linear-gradient(180deg,#07102a 0%, #041026 100%);
    --disabled: rgba(255,255,255,0.12);
    --glass: rgba(255,255,255,0.04);
    --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:var(--font-sans);-webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
  body{display:flex;align-items:center;justify-content:center;overflow:hidden;padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);}
  /* App container sized to logical canvas ratio but scaled to fit screen without scroll */
  #app{
    width:100%;
    max-width:430px;
    height:100%;
    max-height:932px;
    position:relative;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    border-radius:12px;
    overflow:hidden;
    background:var(--ui-bg);
    -webkit-user-select:none; user-select:none;
    touch-action: manipulation;
  }

  /* Two main views: intro crawl and game */
  .view{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:18px;box-sizing:border-box}
  .hidden{display:none}

  /* Canvas wrapper: pixelated retro look */
  #screenWrap{position:relative;flex:1;display:flex;align-items:center;justify-content:center;width:100%}
  canvas#screen{
    width:100%;
    height:100%;
    image-rendering:pixelated;
    display:block;
    background:linear-gradient(180deg,#041026 0%, #07102a 100%);
  }

  /* HUD overlay */
  #hud{position:absolute;left:0;right:0;top:0;padding:12px;display:flex;flex-direction:column;align-items:center;pointer-events:none}
  .topRow{width:100%;display:flex;align-items:center;justify-content:space-between;gap:8px;pointer-events:auto}
  .statBox{background:var(--glass);padding:8px 10px;border-radius:10px;border:2px solid rgba(255,255,255,0.04);display:flex;gap:8px;align-items:center;font-weight:700;color:#fff}
  .statBox .label{font-size:12px;opacity:0.9}
  .bigTimer{font-size:44px;font-weight:900;letter-spacing:1px;text-shadow:0 0 12px rgba(0,255,255,0.25);display:flex;align-items:center;gap:10px}
  .ring{width:64px;height:64px;position:relative;display:inline-block}
  .ring svg{filter:drop-shadow(0 6px 12px rgba(0,255,255,0.08));}

  /* Boss HP bar */
  #bossBarWrap{position:absolute;top:86px;left:50%;transform:translateX(-50%);width:86%;max-width:380px;pointer-events:none}
  #bossBar{height:22px;background:linear-gradient(90deg,#ff6b9a,#ffb86b);border-radius:12px;overflow:hidden;border:3px solid rgba(0,0,0,0.6);box-shadow:0 6px 18px rgba(255,80,150,0.08), inset 0 -6px 18px rgba(0,0,0,0.2)}
  #bossHP{height:100%;width:100%;background:linear-gradient(90deg,#ff3fb5,#ffb86b);transform-origin:left center;transition:width 0.1s linear}
  #bossLabel{position:absolute;left:50%;top:-22px;transform:translateX(-50%);font-weight:900;color:#fff;text-shadow:0 2px 6px rgba(0,0,0,0.6);font-size:14px}

  /* Controls area */
  #controls{position:absolute;bottom:18px;left:0;right:0;display:flex;justify-content:center;gap:12px;pointer-events:auto;padding:0 18px;box-sizing:border-box}
  .btn{background:linear-gradient(180deg,#0ff 0%, #7afcff 100%);border-radius:12px;padding:12px 16px;font-weight:900;color:#041026;border:3px solid rgba(0,0,0,0.35);box-shadow:0 8px 18px rgba(0,0,0,0.4);font-size:16px;min-width:120px;text-align:center;user-select:none;touch-action:manipulation}
  .btn.secondary{background:linear-gradient(180deg,#ff3fb5 0%, #ff8fc9 100%);color:#041026}
  .btn.ghost{background:transparent;border:2px dashed rgba(255,255,255,0.06);color:#fff}
  .btn[aria-disabled="true"],.btn.disabled{opacity:0.35;pointer-events:none;filter:grayscale(0.2) saturate(0.6)}
  .smallRow{display:flex;gap:8px;align-items:center}

  /* Intro crawl styling */
  #intro{background:linear-gradient(180deg,#020617 0%, #041026 100%);align-items:stretch;padding:18px}
  .crawlWrap{flex:1;display:flex;align-items:flex-end;justify-content:center;position:relative;overflow:hidden}
  .crawl{width:100%;max-width:380px;color:#ffd;transform-origin:center bottom;perspective:600px;font-weight:700;line-height:1.4;text-align:center}
  .crawl p{margin:0 0 12px 0;font-size:18px;text-shadow:0 2px 8px rgba(0,0,0,0.6)}
  .crawl .title{font-size:20px;color:var(--accent);letter-spacing:1px}
  .crawl .small{font-size:14px;opacity:0.9}
  .introButtons{display:flex;gap:10px;justify-content:center;padding:12px}
  .toggles{display:flex;gap:8px;align-items:center;justify-content:center;padding:8px}

  /* Halftone overlay and vignette */
  .overlayHalftone{position:absolute;inset:0;pointer-events:none;background-image:
    radial-gradient(circle at 10% 10%, rgba(255,255,255,0.02) 0, transparent 20%),
    radial-gradient(circle at 90% 90%, rgba(255,255,255,0.02) 0, transparent 20%);}
  .vignette{position:absolute;inset:0;pointer-events:none;background:radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,0.45) 100%)}

  /* Accessibility helpers */
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

  /* Small responsive tweaks */
  @media (max-width:420px){
    .bigTimer{font-size:36px}
    .btn{min-width:100px;padding:10px 12px;font-size:15px}
  }

  /* CRT scanlines drawn on canvas; also add CSS scanline overlay for extra effect */
  .scanlines{position:absolute;inset:0;pointer-events:none;background-image:linear-gradient(rgba(0,0,0,0.06) 50%, rgba(255,255,255,0.01) 51%);background-size:100% 4px;mix-blend-mode:overlay;opacity:0.6}
  /* Halftone dots overlay for comic texture */
  .dots{position:absolute;inset:0;pointer-events:none;background-image:
    radial-gradient(circle at 10% 10%, rgba(0,0,0,0.02) 0, transparent 20%),
    radial-gradient(circle at 50% 50%, rgba(0,0,0,0.02) 0, transparent 20%);opacity:0.6;mix-blend-mode:overlay}
</style>
</head>
<body>
<div id="app" role="application" aria-label="Titan Omega Chrono Sync toothbrush game">
  <!-- Intro View -->
  <section id="viewIntro" class="view">
    <div style="width:100%;display:flex;justify-content:space-between;align-items:center;">
      <div style="display:flex;gap:8px;align-items:center">
        <div style="font-weight:900;font-size:18px;color:var(--accent)">TITAN OMEGA</div>
        <div style="font-size:12px;opacity:0.9">CHRONO SYNC</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <label style="font-size:12px;opacity:0.9">Pilot</label>
        <input id="pilotInput" type="text" inputmode="text" placeholder="Your name" style="padding:6px 8px;border-radius:8px;border:2px solid rgba(255,255,255,0.06);background:transparent;color:#fff;font-weight:700;min-width:120px" />
      </div>
    </div>

    <div class="crawlWrap" aria-hidden="false">
      <div id="crawl" class="crawl" aria-live="polite" role="article" aria-label="Mission briefing">
        <div class="title">MISSION: CHRONO SYNC</div>
        <p class="small">Pilot, your mission is simple: brush for two minutes and sync the Chrono Core. The Titan will fall if you keep steady. Sparkles and speed lines will cheer you on.</p>
        <p>Brush with care. Stay bright. Defeat the Titan. Earn crystals and build your streak.</p>
        <p style="opacity:0.9">This intro can be edited in the source. Default crawl lasts 5 seconds.</p>
      </div>
    </div>

    <div class="introButtons" role="toolbar" aria-label="Intro controls">
      <button id="startIntroBtn" class="btn" aria-label="Start mission" touch-action="manipulation">START MISSION</button>
      <button id="skipIntroBtn" class="btn secondary" aria-label="Skip intro" touch-action="manipulation">SKIP INTRO</button>
    </div>

    <div class="toggles" style="margin-top:8px">
      <label style="display:flex;gap:6px;align-items:center"><input id="reducedMotion" type="checkbox" /> Reduced motion</label>
      <label style="display:flex;gap:6px;align-items:center"><input id="highContrast" type="checkbox" /> High contrast</label>
    </div>

    <div style="height:12px"></div>
    <div style="font-size:12px;opacity:0.9;text-align:center">Designed for kids â€” big buttons, bright colors, and friendly encouragement.</div>
  </section>

  <!-- Game View -->
  <section id="viewGame" class="view hidden" aria-hidden="true">
    <div id="screenWrap" aria-hidden="false">
      <canvas id="screen" width="430" height="932" role="img" aria-label="Game screen"></canvas>
      <div class="overlayHalftone"></div>
      <div class="vignette"></div>
      <div class="scanlines"></div>
      <div class="dots"></div>
      <div id="hud" aria-hidden="false">
        <div class="topRow">
          <div class="statBox" id="crystalBox" aria-live="polite"><div style="font-size:18px">ðŸ’Ž</div><div><div class="label">Crystals</div><div id="crystals" style="font-size:16px">0</div></div></div>
          <div class="bigTimer" role="timer" aria-live="assertive" aria-atomic="true">
            <div class="ring" aria-hidden="true" id="progressRing"></div>
            <div id="timerText">02:00</div>
          </div>
          <div class="statBox" id="streakBox" aria-live="polite"><div style="font-size:18px">ðŸ”¥</div><div><div class="label">Streak</div><div id="streak" style="font-size:16px">0</div></div></div>
        </div>
      </div>

      <div id="bossBarWrap" aria-hidden="false">
        <div id="bossLabel">TITAN CORE</div>
        <div id="bossBar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100" aria-label="Titan health">
          <div id="bossHP"></div>
        </div>
      </div>

    </div>

    <div id="controls" role="toolbar" aria-label="Game controls">
      <div class="smallRow">
        <button id="tapBtn" class="btn ghost" aria-label="Tap for sparkle" touch-action="manipulation">TAP FOR SPARKLE</button>
        <button id="startBtn" class="btn" aria-label="Start brushing" touch-action="manipulation">START</button>
        <button id="pauseBtn" class="btn secondary" aria-label="Pause" touch-action="manipulation">PAUSE</button>
        <button id="backIntroBtn" class="btn ghost" aria-label="Back to intro" touch-action="manipulation">BACK</button>
      </div>
      <div style="height:8px"></div>
      <div class="smallRow">
        <button id="muteBtn" class="btn ghost" aria-label="Mute" touch-action="manipulation">MUTE</button>
        <button id="skipBtn" class="btn ghost" aria-label="Skip countdown" touch-action="manipulation">SKIP</button>
      </div>
    </div>

    <div style="position:absolute;left:12px;bottom:12px;font-size:12px;opacity:0.9">Pilot: <span id="pilotName">â€”</span></div>
  </section>
</div>

<!-- Single-file script with labeled sections -->
<script>
/* CONFIG
   - All tunable constants live here.
*/
const CONFIG = {
  canvasW: 430,
  canvasH: 932,
  crawlDuration: 5.0,        // seconds (editable)
  preCountdown: 5.0,         // seconds numeric countdown
  duration: 120.0,           // main brushing duration in seconds
  bossMaxHP: 100.0,          // boss HP units
  particlePoolSize: 120,
  sparklePoolSize: 60,
  starCount: 80,
  audioEnabledDefault: true,
  localKeys: {
    crystals: 'titan_crystals',
    streak: 'titan_streak',
    best: 'titan_best',
    pilot: 'titan_pilot'
  }
};

/* STATE
   - Runtime state variables.
*/
const STATE = {
  view: 'intro', // 'intro' or 'game'
  running: false,
  brushing: false, // true during the 2:00 session
  paused: false,
  mute: false,
  audioReady: false,
  lastTime: 0,
  accum: 0,
  bossHP: CONFIG.bossMaxHP,
  bossMaxHP: CONFIG.bossMaxHP,
  crystals: 0,
  streak: 0,
  best: 0,
  pilot: '',
  countdown: CONFIG.preCountdown,
  crawlPlaying: false,
  reducedMotion: false,
  highContrast: false,
  // deterministic drain per second
  drainPerSecond: CONFIG.bossMaxHP / CONFIG.duration
};

/* CANVAS SETUP
   - Logical canvas resolution and scaling for crisp retro look.
*/
const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d', { alpha: false });
canvas.width = CONFIG.canvasW;
canvas.height = CONFIG.canvasH;

/* UTILS
   - Helper functions for time, formatting, DOM, localStorage.
*/
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function fmtTime(s){
  s = Math.max(0, Math.floor(s));
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return `${mm}:${ss}`;
}
function $(id){return document.getElementById(id)}
function now(){return performance.now()/1000}
function saveLS(key,val){localStorage.setItem(key,JSON.stringify(val))}
function loadLS(key,def){try{const v=JSON.parse(localStorage.getItem(key));return v===null?def:v}catch(e){return def}}

/* AUDIO
   - Lightweight WebAudio synth for beeps and victory.
   - AudioContext must be resumed on user gesture for iOS reliability.
*/
let audioCtx = null;
let masterGain = null;
function ensureAudio(){
  if(audioCtx) return;
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = STATE.mute ? 0 : 1;
    masterGain.connect(audioCtx.destination);
    STATE.audioReady = true;
  }catch(e){
    console.warn('Audio not available', e);
    STATE.audioReady = false;
  }
}
function setMute(m){ STATE.mute = m; if(masterGain) masterGain.gain.value = m ? 0 : 1; saveLS('titan_mute', m); updateMuteUI(); }
function beep(freq=880, time=0.08, type='sine', when=0){
  if(!STATE.audioReady || STATE.mute) return;
  const t = audioCtx.currentTime + when;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = 0.0001;
  o.connect(g); g.connect(masterGain);
  o.start(t);
  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.12, t + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t + time);
  o.stop(t + time + 0.02);
}
function beepSequence(count, startFreq=880, step=-120, spacing=0.25){
  for(let i=0;i<count;i++){
    beep(startFreq + i*step, 0.12, 'sawtooth', i*spacing);
  }
}
function victoryTone(){
  if(!STATE.audioReady || STATE.mute) return;
  const t = audioCtx.currentTime;
  const o1 = audioCtx.createOscillator();
  const o2 = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o1.type='sine'; o2.type='sine';
  o1.frequency.value=880; o2.frequency.value=1320;
  g.gain.value=0.0001;
  o1.connect(g); o2.connect(g); g.connect(masterGain);
  o1.start(t); o2.start(t);
  g.gain.exponentialRampToValueAtTime(0.18, t+0.02);
  g.gain.exponentialRampToValueAtTime(0.0001, t+1.2);
  o1.stop(t+1.25); o2.stop(t+1.25);
}

/* POOLS
   - Object pools for particles and sparkles to avoid allocations.
*/
class Pool {
  constructor(createFn, size){
    this.createFn = createFn;
    this.items = [];
    for(let i=0;i<size;i++) this.items.push(createFn());
  }
  acquire(){
    return this.items.length ? this.items.pop() : this.createFn();
  }
  release(item){ this.items.push(item); }
}

/* Particle and sparkle definitions */
function createParticle(){
  return {x:0,y:0,vx:0,vy:0,life:0,maxLife:0,size:1,color:'#fff',active:false};
}
function createSparkle(){
  return {x:0,y:0,age:0,life:0,size:0,angle:0,active:false};
}
const particlePool = new Pool(createParticle, CONFIG.particlePoolSize);
const sparklePool = new Pool(createSparkle, CONFIG.sparklePoolSize);
const activeParticles = [];
const activeSparkles = [];

/* STARS
   - Procedural starfield for background motion.
*/
const stars = [];
function initStars(){
  stars.length = 0;
  for(let i=0;i<CONFIG.starCount;i++){
    stars.push({
      x: Math.random()*CONFIG.canvasW,
      y: Math.random()*CONFIG.canvasH,
      z: Math.random()*1,
      size: Math.random()*2+0.5,
      speed: 10 + Math.random()*40
    });
  }
}

/* BOSS
   - Boss drawing and deterministic HP drain logic.
   - Drain per second computed from CONFIG.bossMaxHP / CONFIG.duration.
*/
function resetBoss(){
  STATE.bossHP = STATE.bossMaxHP = CONFIG.bossMaxHP;
  STATE.drainPerSecond = CONFIG.bossMaxHP / CONFIG.duration;
  updateBossUI();
}
/* Nontrivial math note:
   Deterministic drain: each frame we subtract drainPerSecond * dt.
   This ensures that over exactly CONFIG.duration seconds, bossHP will reach zero:
     bossHP(t) = bossMaxHP - drainPerSecond * t
   where drainPerSecond = bossMaxHP / duration.
   Using clamped dt avoids jumps if the tab was suspended.
*/

/* INPUT
   - Attach handlers on DOMContentLoaded and include touchend handlers.
*/
document.addEventListener('DOMContentLoaded', initHandlers, {passive:true});

function initHandlers(){
  // Elements
  const startIntroBtn = $('startIntroBtn');
  const skipIntroBtn = $('skipIntroBtn');
  const startBtn = $('startBtn');
  const pauseBtn = $('pauseBtn');
  const tapBtn = $('tapBtn');
  const backIntroBtn = $('backIntroBtn');
  const muteBtn = $('muteBtn');
  const skipBtn = $('skipBtn');
  const pilotInput = $('pilotInput');
  const reducedMotion = $('reducedMotion');
  const highContrast = $('highContrast');

  // Load persistent state
  STATE.crystals = loadLS(CONFIG.localKeys.crystals, 0);
  STATE.streak = loadLS(CONFIG.localKeys.streak, 0);
  STATE.best = loadLS(CONFIG.localKeys.best, 0);
  STATE.pilot = loadLS(CONFIG.localKeys.pilot, '');
  STATE.mute = loadLS('titan_mute', !CONFIG.audioEnabledDefault ? true : false);

  $('crystals').textContent = STATE.crystals;
  $('streak').textContent = STATE.streak;
  $('streak').setAttribute('aria-label', `Current streak ${STATE.streak}`);
  $('pilotName').textContent = STATE.pilot || 'â€”';
  pilotInput.value = STATE.pilot || '';

  // Reduced motion and contrast
  STATE.reducedMotion = reducedMotion.checked;
  STATE.highContrast = highContrast.checked;
  reducedMotion.addEventListener('change', ()=>{ STATE.reducedMotion = reducedMotion.checked; });
  highContrast.addEventListener('change', ()=>{ STATE.highContrast = highContrast.checked; document.body.style.filter = STATE.highContrast ? 'contrast(1.2) saturate(1.2)' : 'none'; });

  // Ensure audio context created on first gesture
  function resumeAudioOnGesture(){
    ensureAudio();
    if(audioCtx && audioCtx.state === 'suspended'){
      audioCtx.resume().then(()=>{ STATE.audioReady = true; });
    }
    document.removeEventListener('touchend', resumeAudioOnGesture);
    document.removeEventListener('click', resumeAudioOnGesture);
  }
  document.addEventListener('touchend', resumeAudioOnGesture, {passive:true});
  document.addEventListener('click', resumeAudioOnGesture, {passive:true});

  // Intro buttons
  startIntroBtn.addEventListener('click', startIntroFlow);
  startIntroBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); startIntroFlow(); });
  skipIntroBtn.addEventListener('click', ()=>{ playCrawl(true); });
  skipIntroBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); playCrawl(true); });

  // Game buttons
  startBtn.addEventListener('click', ()=>{ startPrecountdown(); });
  startBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); startPrecountdown(); });

  pauseBtn.addEventListener('click', togglePause);
  pauseBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); togglePause(); });

  tapBtn.addEventListener('click', ()=>{ handleTap(); });
  tapBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); handleTap(); });

  backIntroBtn.addEventListener('click', ()=>{ setView('intro'); });
  backIntroBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); setView('intro'); });

  muteBtn.addEventListener('click', ()=>{ setMute(!STATE.mute); });
  muteBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); setMute(!STATE.mute); });

  skipBtn.addEventListener('click', ()=>{ skipCountdownOrCrawl(); });
  skipBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); skipCountdownOrCrawl(); });

  // Pilot input non-blocking save
  pilotInput.addEventListener('input', ()=>{ STATE.pilot = pilotInput.value.trim().slice(0,20); $('pilotName').textContent = STATE.pilot || 'â€”'; saveLS(CONFIG.localKeys.pilot, STATE.pilot); });

  // Keyboard controls
  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Space'){ e.preventDefault(); if(!STATE.brushing) handleTap(); }
    if(e.key === 'p' || e.key === 'P'){ e.preventDefault(); if(!STATE.brushing) togglePause(); }
    if(e.key === 'm' || e.key === 'M'){ e.preventDefault(); setMute(!STATE.mute); }
  });

  // Initialize visuals and state
  initStars();
  resetBoss();
  updateMuteUI();
  updateButtonsEnabled(true);
  drawStaticHUD();
  // Expose debug hooks
  window.__TITAN = { state: STATE, startGame: startPrecountdown, setView };
}

/* UI helpers */
function updateMuteUI(){
  const muteBtn = $('muteBtn');
  muteBtn.textContent = STATE.mute ? 'UNMUTE' : 'MUTE';
  muteBtn.setAttribute('aria-pressed', String(STATE.mute));
}
function updateBossUI(){
  const hpPct = clamp(STATE.bossHP / STATE.bossMaxHP, 0, 1);
  $('bossHP').style.width = (hpPct*100) + '%';
  $('bossBar').setAttribute('aria-valuenow', Math.round(hpPct*100));
}
function updateTimerUI(remaining){
  $('timerText').textContent = fmtTime(Math.ceil(remaining));
  $('timerText').setAttribute('aria-live','assertive');
}
function updateCrystalsUI(){
  $('crystals').textContent = STATE.crystals;
}
function updateStreakUI(){
  $('streak').textContent = STATE.streak;
}

/* setButtonsEnabled toggles interactive controls; during brushing they must be disabled */
function updateButtonsEnabled(enabled){
  const ids = ['tapBtn','startBtn','pauseBtn','backIntroBtn','skipBtn'];
  ids.forEach(id=>{
    const el = $(id);
    if(!el) return;
    if(enabled){
      el.removeAttribute('aria-disabled');
      el.classList.remove('disabled');
      el.setAttribute('tabindex','0');
    } else {
      el.setAttribute('aria-disabled','true');
      el.classList.add('disabled');
      el.setAttribute('tabindex','-1');
    }
  });
}

/* VIEW management */
function setView(v){
  STATE.view = v;
  if(v === 'intro'){
    $('viewIntro').classList.remove('hidden');
    $('viewGame').classList.add('hidden');
    $('viewIntro').setAttribute('aria-hidden','false');
    $('viewGame').setAttribute('aria-hidden','true');
  } else {
    $('viewIntro').classList.add('hidden');
    $('viewGame').classList.remove('hidden');
    $('viewIntro').setAttribute('aria-hidden','true');
    $('viewGame').setAttribute('aria-hidden','false');
  }
}

/* INTRO CRAWL
   - Star Wars style crawl implemented with CSS transforms and JS timing.
*/
let crawlTimer = null;
function startIntroFlow(){
  // Non-blocking pilot prompt already provided; ensure audio ready
  ensureAudio();
  setView('intro');
  playCrawl(false);
}
function playCrawl(skip=false){
  const crawlEl = $('crawl');
  const duration = skip ? 0.05 : CONFIG.crawlDuration;
  // Reset transform
  crawlEl.style.transition = 'none';
  crawlEl.style.transform = 'translateY(40%) rotateX(25deg) scale(1)';
  // Force reflow
  void crawlEl.offsetWidth;
  // Start animation
  crawlEl.style.transition = `transform ${duration}s linear`;
  // Move it up and away
  crawlEl.style.transform = 'translateY(-220%) rotateX(25deg) scale(0.6)';
  // Play a soft whoosh
  ensureAudio();
  if(STATE.audioReady && !STATE.mute) beepSequence(3, 1200, -200, 0.08);
  STATE.crawlPlaying = true;
  // After crawl duration, start pre-countdown
  clearTimeout(crawlTimer);
  crawlTimer = setTimeout(()=>{ STATE.crawlPlaying = false; startPrecountdown(); }, Math.max(50, duration*1000));
}

/* Pre-countdown numeric 5s with beeps */
let countdownInterval = null;
function startPrecountdown(){
  // Switch to game view
  setView('game');
  // Disable controls during pre-countdown and brushing
  updateButtonsEnabled(false);
  STATE.brushing = true; // mark brushing to disable input
  STATE.countdown = CONFIG.preCountdown;
  updateTimerUI(STATE.countdown + CONFIG.duration); // show full time until brushing starts
  // Play numeric countdown with beeps
  ensureAudio();
  let t = Math.ceil(STATE.countdown);
  // Show big numeric overlay on canvas during countdown
  startCountdownVisual(STATE.countdown);
  if(STATE.audioReady && !STATE.mute) beep(880,0.12,'sine');
  clearInterval(countdownInterval);
  countdownInterval = setInterval(()=>{
    t--;
    if(t>0){
      if(STATE.audioReady && !STATE.mute) beep(880 - (t*40), 0.12, 'square');
    } else {
      clearInterval(countdownInterval);
      // small final beep and start main timer
      if(STATE.audioReady && !STATE.mute) beep(1200,0.18,'sawtooth');
      startMainTimer();
    }
  },1000);
}

/* Skip countdown or crawl */
function skipCountdownOrCrawl(){
  if(STATE.crawlPlaying){
    clearTimeout(crawlTimer);
    STATE.crawlPlaying = false;
    startPrecountdown();
  } else if(STATE.brushing && STATE.countdown > 0){
    // If in pre-countdown, skip to main timer start
    clearInterval(countdownInterval);
    startMainTimer();
  }
}

/* Main timer: 120s deterministic boss HP drain */
let mainStartTime = 0;
let mainElapsed = 0;
function startMainTimer(){
  // Reset boss and timer
  resetBoss();
  mainStartTime = now();
  mainElapsed = 0;
  STATE.brushing = true;
  STATE.paused = false;
  STATE.running = true;
  // Buttons disabled during brushing
  updateButtonsEnabled(false);
  // Set timer UI to full duration
  updateTimerUI(CONFIG.duration);
  // Start loop
  STATE.lastTime = performance.now();
  requestAnimationFrame(loop);
}

/* Pause/resume (disabled during brushing) */
function togglePause(){
  if(STATE.brushing) return; // disabled during brushing
  STATE.paused = !STATE.paused;
  const pauseBtn = $('pauseBtn');
  pauseBtn.textContent = STATE.paused ? 'RESUME' : 'PAUSE';
  if(!STATE.paused && !STATE.running){
    // start loop if needed
    STATE.lastTime = performance.now();
    requestAnimationFrame(loop);
  }
}

/* Tap action: sparkles and small audio; disabled during brushing */
function handleTap(){
  if(STATE.brushing) return;
  // Create sparkles at random position on canvas
  const s = sparklePool.acquire();
  s.x = Math.random() * CONFIG.canvasW;
  s.y = Math.random() * CONFIG.canvasH * 0.6 + CONFIG.canvasH*0.2;
  s.age = 0; s.life = 0.6 + Math.random()*0.6; s.size = 6 + Math.random()*8; s.angle = Math.random()*Math.PI*2; s.active = true;
  activeSparkles.push(s);
  if(STATE.audioReady && !STATE.mute) beep(1200 + Math.random()*400, 0.08, 'triangle');
}

/* UPDATE
   - Game state update per frame.
*/
function update(dt){
  // Clamp dt to avoid large jumps
  dt = clamp(dt, 0, 0.05);

  // Update stars
  for(let s of stars){
    s.y += s.speed * dt;
    if(s.y > CONFIG.canvasH + 10){ s.y = -10; s.x = Math.random()*CONFIG.canvasW; s.z = Math.random(); }
  }

  // If brushing (main timer running), drain boss HP deterministically
  if(STATE.running && STATE.brushing && !STATE.paused){
    // Deterministic drain: bossHP -= drainPerSecond * dt
    STATE.bossHP -= STATE.drainPerSecond * dt;
    if(STATE.bossHP <= 0){
      STATE.bossHP = 0;
      // Victory: stop timer and trigger end
      updateBossUI();
      endBrushing(true);
      return;
    }
    // Update timer remaining
    mainElapsed = now() - mainStartTime;
    const remaining = Math.max(0, CONFIG.duration - mainElapsed);
    updateTimerUI(remaining);
    // If time elapsed reached duration, end brushing (should coincide with bossHP==0)
    if(mainElapsed >= CONFIG.duration){
      STATE.bossHP = 0;
      updateBossUI();
      endBrushing(true);
      return;
    }
  }

  // Update particles
  for(let i=activeParticles.length-1;i>=0;i--){
    const p = activeParticles[i];
    p.life -= dt;
    if(p.life <= 0){
      activeParticles.splice(i,1);
      particlePool.release(p);
      continue;
    }
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 80 * dt; // gravity
  }

  // Update sparkles
  for(let i=activeSparkles.length-1;i>=0;i--){
    const s = activeSparkles[i];
    s.age += dt;
    if(s.age >= s.life){
      activeSparkles.splice(i,1);
      sparklePool.release(s);
      continue;
    }
    // spawn small particles from sparkle
    if(Math.random() < 0.12){
      const p = particlePool.acquire();
      p.x = s.x + (Math.random()-0.5)*12;
      p.y = s.y + (Math.random()-0.5)*12;
      const ang = Math.random()*Math.PI*2;
      const spd = 40 + Math.random()*120;
      p.vx = Math.cos(ang)*spd;
      p.vy = Math.sin(ang)*spd - 20;
      p.life = 0.4 + Math.random()*0.6;
      p.maxLife = p.life;
      p.size = 1 + Math.random()*3;
      p.color = (Math.random()<0.5) ? '#fff' : '#ff3fb5';
      p.active = true;
      activeParticles.push(p);
    }
  }
}

/* RENDER
   - Draw everything on canvas: stars, boss, particles, sparkles, speed lines, CRT glow.
*/
function render(){
  // Clear
  ctx.fillStyle = '#041026';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Stars
  for(let s of stars){
    const brightness = 0.6 + s.z*0.6;
    ctx.fillStyle = `rgba(255,255,255,${0.06 + brightness*0.12})`;
    const size = s.size * (1 + s.z*1.2);
    ctx.beginPath();
    ctx.ellipse(s.x, s.y, size, size, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // Speed lines (comic effect) near top-right when brushing
  if(STATE.brushing){
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 2;
    for(let i=0;i<8;i++){
      ctx.beginPath();
      const x = canvas.width * 0.6 + i*6;
      ctx.moveTo(x, 40 + (i%2)*6);
      ctx.lineTo(x + 40, 10 + (i%3)*8);
      ctx.stroke();
    }
  }

  // Boss (rounded rectangle with core)
  const bx = canvas.width*0.1;
  const bw = canvas.width*0.8;
  const by = canvas.height*0.18;
  const bh = 120;
  // Outline
  ctx.save();
  ctx.shadowColor = 'rgba(255,80,150,0.25)';
  ctx.shadowBlur = 18;
  roundRect(ctx, bx, by, bw, bh, 18);
  ctx.fillStyle = '#0b1220';
  ctx.fill();
  ctx.lineWidth = 6;
  ctx.strokeStyle = '#ff3fb5';
  ctx.stroke();
  ctx.restore();

  // Core glow
  const coreX = bx + bw/2;
  const coreY = by + bh/2;
  const coreR = 36;
  const hpPct = clamp(STATE.bossHP / STATE.bossMaxHP, 0, 1);
  const glow = 0.2 + (1-hpPct)*0.8;
  const grad = ctx.createRadialGradient(coreX, coreY, 6, coreX, coreY, coreR*3);
  grad.addColorStop(0, `rgba(255,255,255,${0.9*glow})`);
  grad.addColorStop(0.3, `rgba(255,120,180,${0.6*glow})`);
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(coreX, coreY, coreR*3, 0, Math.PI*2);
  ctx.fill();

  // Core circle
  ctx.beginPath();
  ctx.arc(coreX, coreY, coreR, 0, Math.PI*2);
  ctx.fillStyle = `rgba(255,80,150,${0.9})`;
  ctx.fill();
  ctx.lineWidth = 4;
  ctx.strokeStyle = '#fff';
  ctx.stroke();

  // HP bar overlay (drawn as comic outline)
  const hpW = bw * hpPct;
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(bx, by + bh + 12, bw, 12);
  ctx.fillStyle = `linear-gradient(90deg,#ff3fb5,#ffb86b)`;
  ctx.fillStyle = `rgba(255,80,150,${0.9})`;
  ctx.fillRect(bx, by + bh + 12, hpW, 12);

  // Particles
  for(let p of activeParticles){
    const lifeRatio = p.life / p.maxLife;
    ctx.globalAlpha = clamp(lifeRatio,0,1);
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.ellipse(p.x, p.y, p.size, p.size, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Sparkles
  for(let s of activeSparkles){
    const t = s.age / s.life;
    const alpha = 1 - t;
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(s.angle + t*6);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(0, -s.size*0.6);
    ctx.lineTo(s.size*0.2, 0);
    ctx.lineTo(0, s.size*0.6);
    ctx.lineTo(-s.size*0.2, 0);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // CRT scanline effect (subtle)
  ctx.fillStyle = 'rgba(0,0,0,0.02)';
  for(let y=0;y<canvas.height;y+=4){
    ctx.fillRect(0,y,canvas.width,1);
  }

  // HUD glow: timer ring
  drawTimerRing();

  // Reset global alpha
  ctx.globalAlpha = 1;
}

/* Helper: rounded rectangle */
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* Timer ring drawing using canvas for glow */
function drawTimerRing(){
  const ring = $('progressRing');
  // We'll draw an SVG ring into the ring element for crispness
  const remaining = STATE.running && STATE.brushing ? Math.max(0, CONFIG.duration - (now() - mainStartTime)) : CONFIG.duration;
  const pct = clamp(remaining / CONFIG.duration, 0, 1);
  const size = 64;
  const stroke = 6;
  const r = (size - stroke)/2;
  const c = 2*Math.PI*r;
  const dash = c * pct;
  const svg = `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
    <defs><filter id="g"><feGaussianBlur stdDeviation="3" result="b"/></filter></defs>
    <circle cx="${size/2}" cy="${size/2}" r="${r}" stroke="rgba(255,255,255,0.06)" stroke-width="${stroke}" fill="none"/>
    <circle cx="${size/2}" cy="${size/2}" r="${r}" stroke="${STATE.highContrast ? '#fff' : '#00f0ff'}" stroke-width="${stroke}" stroke-linecap="round" fill="none"
      stroke-dasharray="${dash} ${c-dash}" transform="rotate(-90 ${size/2} ${size/2})" style="filter:url(#g);opacity:0.95"/>
  </svg>`;
  ring.innerHTML = svg;
}

/* Countdown visual overlay (simple big numbers) */
let countdownOverlayTimer = null;
function startCountdownVisual(seconds){
  const overlay = document.createElement('div');
  overlay.style.position='absolute';
  overlay.style.inset='0';
  overlay.style.display='flex';
  overlay.style.alignItems='center';
  overlay.style.justifyContent='center';
  overlay.style.pointerEvents='none';
  overlay.style.fontSize='120px';
  overlay.style.fontWeight='900';
  overlay.style.color='rgba(255,255,255,0.95)';
  overlay.style.textShadow='0 6px 18px rgba(0,0,0,0.6)';
  overlay.style.zIndex='999';
  overlay.id = 'countOverlay';
  $('screenWrap').appendChild(overlay);
  let t = Math.ceil(seconds);
  overlay.textContent = t;
  if(STATE.audioReady && !STATE.mute) beep(880,0.12,'sine');
  countdownOverlayTimer = setInterval(()=>{
    t--;
    if(t>0){
      overlay.textContent = t;
      if(STATE.audioReady && !STATE.mute) beep(880 - (t*40), 0.12, 'square');
    } else {
      clearInterval(countdownOverlayTimer);
      overlay.remove();
    }
  },1000);
}

/* END BRUSHING
   - Called when timer finishes or boss reaches zero.
*/
function endBrushing(victory){
  STATE.running = false;
  STATE.brushing = false;
  updateButtonsEnabled(true);
  // Update persistent stats
  if(victory){
    STATE.crystals += 5; // reward
    STATE.streak += 1;
    STATE.best = Math.max(STATE.best, STATE.streak);
    if(STATE.audioReady && !STATE.mute) victoryTone();
  } else {
    STATE.streak = 0;
  }
  saveLS(CONFIG.localKeys.crystals, STATE.crystals);
  saveLS(CONFIG.localKeys.streak, STATE.streak);
  saveLS(CONFIG.localKeys.best, STATE.best);
  // Update UI
  updateCrystalsUI();
  updateStreakUI();
  updateBossUI();
  updateTimerUI(0);
  // Small celebration particles
  for(let i=0;i<20;i++){
    const p = particlePool.acquire();
    p.x = CONFIG.canvasW*0.5 + (Math.random()-0.5)*80;
    p.y = CONFIG.canvasH*0.4 + (Math.random()-0.5)*40;
    const ang = Math.random()*Math.PI*2;
    const spd = 80 + Math.random()*200;
    p.vx = Math.cos(ang)*spd;
    p.vy = Math.sin(ang)*spd - 40;
    p.life = 0.6 + Math.random()*0.8;
    p.maxLife = p.life;
    p.size = 2 + Math.random()*4;
    p.color = (Math.random()<0.5) ? '#7afcff' : '#ff3fb5';
    activeParticles.push(p);
  }
}

/* LOOP
   - Main animation loop with dt clamping and pooling.
*/
function loop(ts){
  const nowMs = performance.now();
  let dt = (nowMs - STATE.lastTime)/1000;
  STATE.lastTime = nowMs;
  // Clamp dt to avoid huge jumps
  dt = clamp(dt, 0, 0.05);
  // Update only if not paused
  if(!STATE.paused){
    update(dt);
  }
  render();
  // Continue loop if running or if there are active particles/sparkles to render
  if(STATE.running || activeParticles.length || activeSparkles.length){
    requestAnimationFrame(loop);
  } else {
    // Still render static HUD occasionally for responsiveness
    requestAnimationFrame(loop);
  }
}

/* DRAW static HUD once */
function drawStaticHUD(){
  updateBossUI();
  updateTimerUI(CONFIG.duration);
  updateCrystalsUI();
  updateStreakUI();
  drawTimerRing();
}

/* Initialization */
(function init(){
  // Ensure safe defaults
  resetBoss();
  initStars();
  // Start an idle render loop to show background
  STATE.lastTime = performance.now();
  requestAnimationFrame(loop);
})();

/* Accessibility: announce timer updates via aria-live already set on timerText */

/* Expose debug hooks and helpers */
window.__TITAN = window.__TITAN || {};
window.__TITAN.state = STATE;
window.__TITAN.startGame = startPrecountdown;
window.__TITAN.setView = setView;
window.__TITAN.resetBoss = resetBoss;
window.__TITAN.forceVictory = ()=>{ STATE.bossHP = 0; updateBossUI(); endBrushing(true); };

</script>
</body>
</html>
